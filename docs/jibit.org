Jibit dev documents. May be bilingual.

* Database solution
[2020-02-16 Sun]

Let's study database libraries for Clojure. Relational or not. I'm
gravitating towards a system that would give me basic M2M things but
of course you don't need RDBMS for that.

** SQL
*** HugSQL
https://www.hugsql.org/

Interesting idea about leaving SQL matters for SQL the DSL. Certainly
intriguing because SQL is arguably the best choice for relational
databases, and all ORM type of language translations occasionally
introduce unnecessary complexity.

Very interesting idea but looking into my use cases in my software I'm
not sure how it will handle dynamically applied filters to a query.
Should investigate more closely!

Somewhat both expectedly and disappointingly the solution is to use
HugSQL when it helps the most and drop down to JDBC calls when you
need maximum dynamism.

*** DONE HoneySQL
CLOSED: [2020-02-28 Fri 18:11]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-02-28 Fri 18:11]
:END:
https://github.com/jkk/honeysql

This is a library for building SQL. You'd use =clojure.jdbc= with this.

The big benefit over Korma here is the flexible map-based query
building. It keeps the ORM at minimum, you're basically talking about
SQL but in flexible Clojure terms.

Even so, will it beat real SQL in its home town? Secondly this project
lacks the connection helper utilities (which is proper because other
projects can so easily build on this one).

*** NOTSURE Korma
CLOSED: [2020-02-16 Sun 17:07]
https://github.com/korma/Korma

Korma used to be a big player back in the day. Looking at it now, it
hasn't seen commits in 2 years.

Korma embraces the Lisp approach of macro-based DSLs. It's all fun and
games but the truth is that the newer school of keeping data real data
(as in, maps) has great benefits.

Combine that DSL macro issue with the lack of activity (although
again, I'm sure it has reached maturity and would work 100% perfectly
with my needs) let's say this is not going to be the first choice.

*** DONE Yesql

Yesql has been put on freeze about 3-4 years ago. I'm sure it'll work
perfectly but let's put this bottom of the stack.

But quickly skimming the readme, shows this is actually closely
resembling HugSQL anyway.

*** NOTSURE Toucan
CLOSED: [2020-02-16 Sun 17:03]
https://github.com/metabase/toucan

A high-level SQL engine, so it's more ORM than the rest. Built on
HoneySQL. This is probably not something that I want to explore at
this time.

** Others

These solutions are probably super cool and all, but I need a local,
offline, preferably one-file solution to store everything. This
gravitates me back to Sqlite and thus, SQL.

*** NOTSURE Datomic
CLOSED: [2020-02-16 Sun 17:31]

Datomic would be so sweet, but it's a big overkill. I want to run an
offline, purely local setup.

*** NOTSURE CouchDB + Clutch
CLOSED: [2020-02-16 Sun 17:31]

** Conclusion

Currently I'm thinking, pure JDBC (Sean Corfield's JDBC.next) + HoneySql.

Let's leverage SQL at the database level, creating suitable views as
needed.

* Data schema

A simple schema for a simple CRUD.

We will want to import most of the EXIF informations into the database
for fast and convenient access.

EXIF tags too, but let's leave that for later.

** Structure plans 

- picture
  - id
  - filename
  - original (raw)
  - rating
  - taken_ts
  - developed_ts
  - import_ts
  - title 
  - description
  - width_pixels
  - height_pixels
  - 
- picture_tag
  - id
  - picture_id  (FK)
  - tag_id      (FK)
  - orderno     (*1)
  - rating      (*2)
- tag
  - id
  - title 
  - tag_type    (*4)
  - description
  - parent_tag  (FK)
  - public    boolean
  - color       (*3)
  - style_attrs (*3)

** Schema annotated
*** Photo
[2020-03-01 Sun]

This is going to be a fat table to be sure, but there's not much wrong
here. Camera and lens manufacturer info is in denormalised form here,
I don't see it being a huge problem. It'll be easy to convert into a
more normalised form later on. Or it'll be difficult, but if so, it'll
be difficult to maintain the relations.

- id
- lens_make :: (String) Lens manufacturer. Not very reliable.
- lens_model :: (String) Exif info about the lens used. Can be empty
  for compact cameras but should otherwise always be populated.
- lens_min_fl :: (Num) zoom lens's widest FL. Prime populated both
  with same.
- lens_max_fl :: (Num) zoom lens's narrowest FL. Prime populated both
  with same.
- focal_length :: (Num) FL used for this shot.
- focal_length_35 :: (Num) for convenience reasons normalized FL in
  35mm equiv.
- aperture :: (Num) used aperture opening for the shot, or its
  inverse, meaning that "4" means the aperture of "1/4".
- exposure_comp :: (Num) exposure compensation value if used camera's
  metering.
- camera_make :: (String) manufacturer of the Camera body.
- camera_model :: (String) model of the Camera body.
- iso :: (Num) ISO speed used to take this shot.
- shutter_speed :: (Num) exposure time, or shutter speed in seconds.
  "0.025" means "1/40" and so on.
- light_value :: (Num) Exiftools or possibly the camera's measured
  light value for fun.
- rating :: (Num) user-given rating in Jibit.
- orig_rating :: (Num) The rating that was encoded with EXIF, given in
  camera or in raw editing tool or existing image managing tool.
- taken_ts :: (datetime) when the shot was taken
- process_ts :: (datetime) when the file was processed in a raw editor
  or similar tool.
- import_ts :: (datetime) when the file was imported to Jibit database.
- width :: (num) width of the image in pixels
- height :: (num) height of the image in pixels
- megapixels :: (num) convenience normalization of the image resolution
- title :: (String) user-given title for the image
- subtitle :: (String) user-given secondary title
- description :: (String) any notes and comments and stories about the
  image.
- notes :: (String) personal notes and comments not meant for exported
- is_raw :: (Boolean) whether the file is a raw file or a bitmap like
     JPEG or PNG.
- original_file  :: (String) the file name of the original file when
  it was imported.
- original_raw :: (String) the location of the raw file the file was
  developed from.
- original_dir :: (String) the name of the directory the file was in,
  when imported.
- uuid :: (String) very unique id 
- storage_filename :: (String) the file name under which the file is
  stored in the file system internally.

** Notes

- 1: If we choose to implement albums using tags, then orderno is
  necessary for adjustment of order. Some places choose to implement
  these two things in separate tables.
- 2: Picture may stand better within a subcontext so it might warrant
  a rating that is only relevant within the tag or album.
- 3: Tag has colors, style (for organisation purposes within Jibit,
  nowhere else). Nested tags shall inherit the parent tag's styling by
  default, but if these colors are defined, they override.
- 4: Not sure if necessary, but flairs and "deletion flags" may
  warrant this kind of type distinction.

** Migrations

SQLite doesn't have good migration support for for example if =TAG=
needs new constraints or something, we first have to create the new
table with all the wanted baggage, move the data over and then try to
drop the old one.

The old one will still have some FK constraints in place.

#+BEGIN_EXAMPLE
  -- Migrate/update table "tag" with new constraints.
  create table tag2
  ( id                      integer primary key autoincrement
  , name                    text not null
  , type                    text
  , description             text
  , parent_id               integer
  , style_color             text
  , style_attrs             text
  , public                  integer
  , foreign key (parent_id) references tag(id) on delete restrict on update cascade
                            check (parent_id != id)
  , unique (name)
  );
  drop index ix_tag_name;       --new
  drop index ix_tag_type;       --new
  drop index ix_tag_parent_id;  --new
  create index ix_tag_name on tag2(name);
  create index ix_tag_type on tag2(type);
  create index ix_tag_parent_id on tag2(parent_id);

  insert into tag2 select * from tag;
  commit;

  -- all done

  alter table tag rename to tag_d;
  alter table tag2 rename to tag;
#+END_EXAMPLE

Look at this TechOnTheNet article about a working pattern:

#+BEGIN_EXAMPLE
  PRAGMA foreign_keys=off;

  BEGIN TRANSACTION;

  ALTER TABLE table1 RENAME TO _table1_old;

  CREATE TABLE table1 (
  ( column1 datatype [ NULL | NOT NULL ],
    column2 datatype [ NULL | NOT NULL ],
    ...
  );

  INSERT INTO table1 (column1, column2, ... column_n)
    SELECT column1, column2, ... column_n
    FROM _table1_old;

  COMMIT;

  PRAGMA foreign_keys=on;
#+END_EXAMPLE

** Tag traps

Tagged photos

: select id from photo
: where id in (select photo_id from photo_tag)

Untagged photos

: select id from photo
: where id not in (select photo_id from photo_tag)

Photos tagged with tag id 3

: select photo.*
: from photo
: where id in (select photo_id from photo_tag where tag_id = 3)

Photos tagged with tag named 'Cars' (id 3)

: select photo.*
: from photo
: where id in (select photo_id from photo_tag where tag_id = (select id from tag where name ='Cars'))

Photos tagged with (UNION) tag 1 or 2

: select id from photo
: where id in (select photo_id from photo_tag where tag_id in (1, 2));

Photos tagged with (INTERSECT) tags 2 and 3. Here's the trick is to have count(id) equal to the amount of tags selected. 

#+BEGIN_EXAMPLE
  SELECT p.*
  FROM photo p
  WHERE EXISTS (
    SELECT NULL 
    FROM photo_tag pt 
    JOIN tag        t ON pt.tag_id = t.id
    WHERE t.id IN (2, 3) 
    AND pt.photo_id = p.id 
    GROUP BY pt.photo_id 
    HAVING count(t.id) = 2);
#+END_EXAMPLE

Can also search by other tag properties easily.

#+BEGIN_EXAMPLE
  SELECT p.*
  FROM photo p
  WHERE EXISTS (
    SELECT NULL 
    FROM photo_tag pt 
    JOIN tag        t ON pt.tag_id = t.id
    WHERE t.name IN ('Red', 'Cars') 
    AND pt.photo_id = p.id 
    GROUP BY pt.photo_id 
    HAVING count(t.id) = 2);
#+END_EXAMPLE
* File Storage

- Meaningful names are meaningful but we have a problem with changing
  the names after metadata changes.
- So maybe just UUIDs for file names. UUID + original extension.
- We can write "views" over the data using hard or soft links and
  those files can be named using any available metadata.
* ClojureScript 1.10.741
[2020-04-26 Sun]

- Looks like this new release causes issues with our stack. The
  underlying issue appears to be google closure updates.
  - figwheel

    #+BEGIN_EXAMPLE
      Use of undeclared Var goog.net.XhrIo/send
    #+END_EXAMPLE

  - taoensso.timbre

    #+BEGIN_EXAMPLE
      Compile Warning: Use of undeclared Var goog.structs/Map
    #+END_EXAMPLE

- Fall back to 1.10.597 for time being.
  - Although we started with version 1.10.520
  - Figwheel-main's docs have been updated to mention about this
    problem so expect a solution soon.

* Trolling the drop box                                              :import:
** About sidecars
[2020-02-23 Sun]

I am saying not to care about these at this point. Our current scope
is to manage end results, not the raw files.

** About raw files
[2020-02-23 Sun]

Good point, then. If we are to ignore sidecars then is it only fair to
also ignore raw files?

** NOTSURE Let's ignore raw files for now.
CLOSED: [2020-03-29 Sun 19:32]

See [[rawthumbnail]] and this discussion above about XMP and raw file things.

If we need raw image preview, we can do it. But it is certain other
problems as well. Thumbnail extraction, thumbnails have to be oriented
properly, so rotation things too.

** TODO HEIF, GIF, WEBM

These are all valid things to manage but we probably have to leave
these for later.

* EXIF parsers
** NOTSURE Drew Noakes: metadata-extractor

This tool looks so promising, is simple and everything. Sadly it
appears to be very incomplete wrt support and functionality. We'll
have to turn to the 'industry standard', Phil Harvey's exiftool.

** DONE Phil Harvey: Exiftool and java bindings

- Java integration https://github.com/mjeanroy/exiftool 
  - Can use exiftool's daemon mode that gives us 25x speedup

** NOTSURE What would libexiv2 do for us?
CLOSED: [2020-04-03 Fri 13:56]

- Darktable and company uses this thing instead of exiftool.
- This has an alternative understanding to lens id's among other things.
- (This also explains why aperture readings are different in darktable
  and in some online forums; different exif libraries used.)
- Exiv2 is a C++ tool and quickly googling around it seems there are
  no hugely popular java bindings available.

* NOTSURE Parse images on import for width/height?
CLOSED: [2020-03-01 Sun 19:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-01 Sun 19:54]
:END:

Pure exiftool output isn't enough. Raw files have funky resolutions
sometimes and do we dare to f.ex round up Leica M's 23.85 megapixels
up to 24?

Probably yes, but also no.

On JPEG files exif tags "ImageWidth" and "ImageHeight" seem to be
correct. Since we don't want to concern us with raw files (and the
whole resolution concept is not super clear) let's trust Phil on this
analysis.

* On accuracy of measurements ISO/Aperture/SS/EC

I would say that if we handle 1/3-stops and 1/2-stops decently from
floating point numbers it's accurate enough to be also statistically
useful.

After all, the DOF differences between f/2.76 and f/2.8 aren't going
to be visible. And movement at 1/28 seconds and 1/30 seconds is
equally blurry.

Light value is probably something we can just show with rounded to two
decimal places.

* DONE Our backend API should be stricter with Access-Control-Allow-Origin
CLOSED: [2020-04-26 Sun 13:05]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-26 Sun 13:05]
:END:

Limit it to localhost? And this is naturally something the production
shouldn't need... Since the same URI serves the JS and the API.

Using a wildcard on local dev setup is not a problem. The header
should not be set in "production" to ensure only local same-host
queries get through.

Now that we combined servers this is unnecessary and extra headers
have been removed.

* NOTSURE Fix import inaccuracies
CLOSED: [2020-03-07 Sat 17:21]

First import looks so good! But some things we should/could fix.

** DONE :import_ts
CLOSED: [2020-03-03 Tue 19:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-03 Tue 19:54]
:END:

This info comes as string repr. Make it so that it's the same as taken_ts/process_ts.

** NOTSURE :lens_make for Canon, Oly
CLOSED: [2020-03-29 Sun 19:33]

<<ambiglens>>

Surely there's no row on exif info about this?

There's only vague heuristics we could utilise here. A better
user-driven solution exists.

*** Exif tags that could be stored

- Olympus: "Lens Type" or "Lens ID" has a long human-readable id of
  the lens and make.
- Canon 5D: "Lens Type/ID" field is here as well. But Exiftool can't
  distinguish between Canon 17-35 and a generic Sigma lens here.
  
In both cases an unambiguous analysis is not possible, heuristics
would be needed.

*** Real solution that will work 100 % of the time

We don't make up anything; instead we ask the user to fill in the info.

We have now Cameras and Lenses in their own tables and user should be
able to mass-edit those photos to reflect what he was using at the
time. Or just leave empty.
* TODO Asking user to fill in missing info on import

We can detect missing lens_make, lens_model, ask user to fill in them
at import. Sigma, Tamron, some russian plastic lens... all is possible
then. See [[ambiglens]] for more.

Other tools we need or benefit from:

- Shift/correct taken_ts timezones 
- mass-apply FL, lens info (leica lenses or other dead lenses)

* DONE Round up all configuration in one EDN file or something
CLOSED: [2020-03-15 Sun 19:08]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-15 Sun 19:08]
:END:

We have stuff in =clurator.inbox=  for starters.

- db
  
We'll ideally want to have this stuff specified either via env or an
edn file. In this case we can skip CLI arguments.

* TODO Configuration rounded up

Keep EDN in considerations though.

* TODO Unit tests
* TODO Filter panel enhancements [5/5]
** DONE Imported "today/yesterday/this week/all time"
CLOSED: [2020-04-26 Sun 11:17]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-26 Sun 11:17]
:END:

First we do a dumb version, then try to import the date selection
widget for all dates.
** DONE Show untitled
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Show untagged
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Show unrated
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Include raws on/off
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
* TODO Fancy date selector

We should build a date selector that has a couple of ways to interact,
and provide some default ranges.

- "today"
- "yesterday"
- "this week"
- "this month"
- between dt-dt

* DONE Tagging photos [100%]
CLOSED: [2020-04-20 Mon 18:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:03]
:END:
** DONE Show existing tags on photos
CLOSED: [2020-04-05 Sun 13:34]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-05 Sun 13:34]
:END:

Let's pass the IDs alone and let jibit join the labels using full
information.

** DONE Selection of photos from lighttable
CLOSED: [2020-04-06 Mon 19:06]
:LOGBOOK:
- State "DONE"       from "NOTSURE"    [2020-04-10 Fri 11:09]
- State "DONE"       from "TODO"       [2020-04-06 Mon 19:06]
:END:

So basically give the ability to tag a photo... we can postpone
selections for later.

** DONE Tag a photo from UI
CLOSED: [2020-04-11 Sat 12:09]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-11 Sat 12:09]
- State "STARTED"    from "TODO"       [2020-04-10 Fri 11:18]
:END:
** NOTSURE Saving tags
CLOSED: [2020-04-10 Fri 11:19]

What's this actually? We go ahead and persist things to DB the moment
we tag/untag photo(s). That's how it's going to be.

** DONE Making new tags [100%]
CLOSED: [2020-04-12 Sun 13:32]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-12 Sun 13:32]
:END:

We're launching a modal div on top of everything to remind us how
great all modal windows used to be.

Things 

- [X] Some refactoring of data-bound-input may be needed.
- [X] We'll want to show user the name is required (don't let user
  click on the Create if empty)
- [X] On "Create" keep the dialog open while request runs, only close
  it once it was successfully saved.
- [X] Spinner is probably not necessary at this point, see how slow it
  is.
- [X] Use a singular piece of state to denote what is shown. =:state
  :new-tag-dlg= and so on.

** DONE Modifying tags
CLOSED: [2020-04-13 Mon 13:15]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-13 Mon 13:15]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:13]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:13]
:END:

We have a bit of refactoring to unify create/modify tag.

Well frankly we didn't need much at all to refactor!

** DONE Modifying tags, make sure "use color" is on 
CLOSED: [2020-04-13 Mon 13:20]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-13 Mon 13:20]
:END:
** DONE Deleting tags
CLOSED: [2020-04-19 Sun 18:39]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-19 Sun 18:39]
- State "STARTED"    from "TODO"       [2020-04-18 Sat 11:09]
:END:

Put this thing under Modify dialog.

- [X] Deleting a tag, enforce tagged items (set null but ask)
- [X] Deleting a tag, enforce parent relation (set null but ask)
- [X] Confirm deleting a tag beforehands

** DONE Tag relations: don't let tag be its own parent
CLOSED: [2020-04-14 Tue 19:35]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-14 Tue 19:35]
:END:

- [X] db constraint?
- [X] ui check definitely

** DONE Cyclical tag ancestors
CLOSED: [2020-04-15 Wed 20:07]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-15 Wed 20:07]
:END:

Cyclic relations can be prohibited during pre-save with this.

| id | pid | tag              |
|----+-----+------------------|
|  1 |     | Cars             |
|  2 |   1 | -- Old Cars      |
|  3 |   1 | -- Red Cars      |
| 66 |   3 | ---- Maroon Cars |
|  4 |     | Blue             |
|  5 |     | Green            |
|  6 |   5 | -- Forest Green  |

Tag 1 (Cars) can't have pid 2, 3 or 66. Tag 5 can't have pid of 6. So
it's the set of all children (descendants) that's verboten.

But tag 66 (Maroon Cars) can be updated to have pid of 1 -- no
restrictions.

So this wishywashy reasoning leaves us to implement a check for
children. Get all descendants as a set and make sure pid is not in
that set.

** DONE Don't launch Post req on an empty selection
CLOSED: [2020-04-11 Sat 17:43]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:43]
:END:

** DONE UI enhancements on Tag Color selection
CLOSED: [2020-04-20 Mon 18:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:03]
:END:

- [X] If user deselects "Use color" checkbox, clear the color from
  colorselector
- [X] If user selects a color using the selector, select "Use color"
  automatically
  
We can bind these to an "on click" event for better or worse.
** DONE Tag parents / hierarchies
CLOSED: [2020-04-14 Tue 16:58]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-14 Tue 16:58]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:02]
:END:

It's persisted on saving new ones.
** DONE Order tags by hierarchy?
CLOSED: [2020-04-14 Tue 18:16]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-14 Tue 18:16]
- State "STARTED"    from "TODO"       [2020-04-14 Tue 17:26]
:END:

** DONE Tag color 
CLOSED: [2020-04-14 Tue 17:24]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-14 Tue 17:24]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:02]
:END:

It's persisted on saving new ones.

If tag has no color, we need to query parent tag for color info, if
there's some.

In our sample data, Cyan (#16) has parent Blue (#1) and should derive
Blue's color. Tag "Nameless" #18 has color of its own and should keep
it.

This inherited color is stored separately as =:tag/computed_color= to
avoid mixing user-given and computed data.
* TODO Automatic tags on import and "system tags"?

- Some of the exif /might/ be useful to have as tags so that it's
  possible to exclude that stuff.
- Then again, it'll introduce a lot of things... perhaps not desired?
  
But we definitely need a way to mass-tag and mass-edit photos by gear,
edit their lens data for example. For that kind of things we have
means to do so with taggings.

But the problem is then that we have an excessive amount of tags to an
image and all that...

This is a nonstarter perhaps, because we have separate fields for that
info in the schema, better go that way? (Or we refactor once more?)

* DONE On click, show image FS
CLOSED: [2020-04-24 Fri 18:34]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-24 Fri 18:34]
:END:

Let's take that good image gallery plugin into the mix. PhotoSwipe is
the name.

** Problems with setting this up

Could be something about React's nature. Separate little things with
CLJS but they're somewhat solved.

This is the current problem:

#+BEGIN_EXAMPLE
  Uncaught DOMException: Failed to execute 'insertBefore' on 'Node': The
  node before which the new node is to be inserted is not a child of
  this node.

    at PhotoSwipe._applyNavBarGaps (http://localhost:9500/cljs-out/dev/cljsjs/photoswipe/development/photoswipe-ui-default.inc.js:351:17)
#+END_EXAMPLE

The line of code in question:

#+BEGIN_SRC js
  _controls.insertBefore(_fakeCaptionContainer, _captionContainer);
#+END_SRC

Where =_controls= points to the div with classes =pswp__ui
pswp__ui--hidden pswp__ui--one-slide=.

This line of error is usually attributed to ReactJS.

*** DONE Bypassed this problem by bypassing making it a React component

So it's plain elements in =index.html= now. Maybe not as elegant but
it's working seamlessly. This is because this library behaves
functionally and very well, doesn't cause distractions. Especially in
my use currently when I don't need that slide show capability.

We /may/ need to revisit this thing later on, but I don't think
current bypassed "hack" is particularly ugly in isolation, nor will
cause trouble.

*** DONE Google about PhotoSwipe + ReactJS 

Nothing interesting

* DONE Image show: disallow raw files                                    :ui:
CLOSED: [2020-04-25 Sat 11:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 11:41]
:END:

We are not going to render raw files by ourselves right now, so what
should happen is that the interface should know photo being
cooked/uncooked (raw).

We should also mark it in the slide if photo is a raw.

* TODO Image name, description fields

We have to think about the UI for this.

* TODO Inspect lighttable/slide performance                     :performance:

Selecting a slide makes about 100 ms or 80 ms optimized and that's
quite a bit. Our render is only 55 slides at the moment so expect a
much worse time in the future.

- Removing the tag labels: no particular effect
- Removing moment.js: no particular effect

* TODO re-frame and multi-arity event handlers?

https://stuartsierra.com/2015/06/01/clojure-donts-optional-arguments-with-varargs

What we used in =:delete-tag= is an antipattern to Stu Sierra so let's
spend a moment to see if re-frame event handlers allow for a better
way.
* TODO Tags as a map in db?                                  :small:refactor:

It's a smart format for tags to be in anyway, maybe we should store
them as an ID:TAG map in the first place?
* TODO Photo insert things from db to model.photo          :backend:refactor:

And we have this bipolar difference in terminology... can we simplify
it, rid of it?

* TODO Tri-state or N-state toggle buttons?                              :ui:

They're built with a seq of keywords-label pairs, plus input where it
binds the selection. Would work nicely for a few cases in our ui.

* Currently held states                                                :info:

: (:state db)

Is a stack that we operate with =conj=, =pop= and =peek=.

- nil :: default
- tag-dialog :: modal, tag edit/creation dialog
- modal-prompt :: modal, generic prompter
     
* Naming conventions                                                   :info:

- Boolean vars should always end in ?
- Vars pointing to "counts" like "photo-count" should be ended with #

* NOTSURE Modal background : dblclick to turn off
CLOSED: [2020-04-25 Sat 12:57]
* TODO Make tags div stick (toggleable)

Maybe good to place under a shortcut?

* TODO What can be done for the dual-confirmation of tag deletion?       :ui:

Two dialogs doesn't look that good. What could be done?

We can absolutely combine the two confirmations in one. Now the first
run will be a "dry run", collecting the potential trouble and then we
confirm regardless of found trouble.

* TODO Slide visual work                                                 :ui:
** TODO Raw indication: show another div over the thumbnail

This div can use all kinds of cool background styles to fade out the raw thumbnail.

** TODO Film slide look?
** TODO Info/details are useless?

* TODO Short messages that show for 2 sec                                :ui:

One place where we could use one: when trying to open up a raw file
and we won't do it. (event =:show-photo=)

* TODO Tag list as a tree or a list                                 :ui:tags:

- We show currently tags as a list (but ordered so that subtags are
  grouped together)
- Alternative view that takes more space might be cool: tree form
  where subtags are indented off from the supertag 

* DONE Selections
CLOSED: [2020-04-11 Sat 17:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:40]
:END:

Mousedown selection with a small hold time to select a photo, and then
you should be able to continue selecting by dragging.

But first things first, mousedown activates on a click and now we have
to time how long the user holds.

This is now done but the implementation leaves much to be desired.

** Mouse down, up, click

These three always occur in this order, on an element. Unless you make
it into a drag event...

** DONE When already having selections, make it faster to select more
CLOSED: [2020-04-10 Fri 11:07]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-10 Fri 11:07]
:END:
** DONE Clear selection only if photo set changes
CLOSED: [2020-04-11 Sat 17:30]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:30]
:END:

Should we perhaps keep the intersection of photos selected? Yes...
* TODO Streamline photo filtering?                                  :backend:

Tags per photo are currently subqueries (and there's that interesting
bug/condition in there relating debug statements).

To get photos and tags in one query, you join =PHOTO_TAG= and collect
=PHOTO_TAG.TAG_ID=.

- One approach gets you duplicate photo rows but with differing tag
  IDs; use clojure to minify
- Another is to use sqlite's =group_concat= function to produce a
  string representation of the IDs. This approach is probably going to
  be a tiny bit faster but there's no flexibility after we want those
  extra bits of information that we store in the M2M relation
  =PHOTO_TAG=.
* TODO Maybe show tiny photo counts per each tag?                      :idea:
* TODO re-pressed

https://github.com/gadfly361/re-pressed

Looks like a solid idea. It manages keyboard events. Probably more
than beneficial.

Added in project deps, experimentation to follow later on.

* TODO UI: show total exp time                                         :idea:

For example user has selected 5 images that have all been exposed
1/250 sec, the total is 1.25 sec.

Let's definitely bake this into when we make little "stats" from selections.

This stats idea would contain things like:

- tag cloud, frequencies
- used FLs, apertures
- used cameras, lenses
- and yes, total exposure time in seconds, minutes, hours?!

* Thumbnails from raws

<<rawthumbnail>>

- Canon CR2: full sized JPEG "PreviewImage"
- Leica Q: full sized JPEG "JpgFromRaw" 
- Leica Q: 1080p JPEG "PreviewImage"
- Leica Q: 720p JPEG "PreviewImage"
- Leica M240: Tiny and medium sized previews "PreviewImage"
- Olympus EPL5: Tiny and large sized previews "PreviewImage" and "ThumbnailImage"

* Misc CLJS/Figwheel things
** Inspect App DB

In CLJS / repl

: re-frame.db/app-db

Alternative tool: ~re-frame-10x~
* Mundane things done
** DONE rename =toggle-button=
CLOSED: [2020-04-17 Fri 18:20]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-17 Fri 18:20]
:END:

Maybe move all data-bound buttons outside
** DONE Check do we need that extra boolean on =data-bound-input=
CLOSED: [2020-04-12 Sun 17:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-12 Sun 17:46]
:END:

Yep, seems like =<input>= element can't be made to imitate a
=<textarea>= quite so easily.

** DONE Refactor error messaging / route handling                  :backend:
CLOSED: [2020-04-17 Fri 17:43]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-17 Fri 17:43]
:END:

As the first thing we need to be sending correct status code when
things go south. The messages and that can be considered later.

Also =create-update-new-tag= needs to move over some place else.

There should be a common protocol about what a route handler's
response should look like.

Minimalistic approach for starters, room to expand?

#+BEGIN_EXAMPLE
  {:status :ok
   :response 'edn-formatted}
#+END_EXAMPLE

And a route handler looks like...

#+BEGIN_EXAMPLE
  (defn xyz [req]
   (let [{code :status-code, resp :response} (xyz-handler req)]
    {:status code
     :headers edn-headers
     :body (prn-str resp)}))
#+END_EXAMPLE

Pretty unified.

Status code can be a number but we don't probs need others than 200 and 500.

** NOTSURE get-photos could be an effect
CLOSED: [2020-04-12 Sun 13:31]

If we pass all the input to it via arguments. Pure style!

I miscalculated the scope of effects handler. Its result aren't indeed
handled the same way the effects are, so let's not go that way.

** DONE Effects and Events
CLOSED: [2020-04-11 Sat 17:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:41]
:END:

We'll have to check how the difference shows, especially when an
effect handler doesn't get cofx like that.

Event handlers and effect handlers are a bit complected right now at
re-frame level so it means we use whatever we need to --
events/handlers even when the behavior is more effect-like. Effects
when we can.

** DONE tags-union into predicate form 
CLOSED: [2020-04-20 Mon 18:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:14]
:END:

Add =?=

** DONE Unify terms in code backend/frontend
CLOSED: [2020-04-04 Sat 13:17]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-04 Sat 13:17]
:END:

- Negatives, photos, images... Just *photo* is good? 
- I guess we can go for "slides" on a "lighttable" in jibit.
  
We could check out the darkroom/lighttable terminology for a hint of
nostalgia to get juices going on.

Let's try to keep "photo" as the common term across the board. Use
"slide" and "lighttable" when talking about the representation.

** DONE [#B] Order-by doesn't update repr if data changes
CLOSED: [2020-04-04 Sat 14:06]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-04 Sat 14:06]
:END:

Never mind, ~<select value="foo">~ does this for us.

** DONE Round up Tags in a rounded div
CLOSED: [2020-04-05 Sun 11:31]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-05 Sun 11:31]
:END:
** DONE inbox: fs/expand-home
CLOSED: [2020-03-29 Sun 19:32]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-29 Sun 19:32]
:END:

This thing should really be done once at settings' reading time.

** DONE Normalize lens/camera info?
CLOSED: [2020-03-28 Sat 17:04]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 17:04]
:END:

Things like Lens_make, lens_model, FL_min, FL_max, aperture info could
be served well to be in its own table to help with data fill-in.

** DONE Fix Thumbnails
CLOSED: [2020-03-28 Sat 10:51]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 10:51]
:END:

Do them on import maybe? 

- We want a way to later on adjust the thumbnail size, redo everything
  in batch

** DONE We need good logging facilities
CLOSED: [2020-03-28 Sat 17:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 17:56]
:END:

Timbre is an old friend, let's set it up.

It's somewhat unmaintained as of today. It works but it's somewhat
hard to configure... Well it's figured out.

The docs are a mess but the "f" variants of logging utilities are
"format" versions. Standard C-style format flags work, with java
dialect.

: (debug "foo" "bar" :fez [2 4 5])
: (debugf "This octal is wicked %o" 42)

** UI things

Have to say, the current [2020-03-28 Sat] color palette is looking
nice. Gold + silver on the front against dark grays on the back.
Bright yellow and red easy to use as warning colors, blue/green easy
to adapt into tags.

** DONE Rename =:cancel-create-tag-dlg=                             :rename:
CLOSED: [2020-04-20 Mon 17:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 17:46]
:END:
** DONE =:open-prompt= -> =:show-prompt=                            :rename:
CLOSED: [2020-04-20 Mon 18:05]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:05]
:END:
** DONE Prepare real data
CLOSED: [2020-02-22 Sat 17:00]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-02-22 Sat 17:00]
:END:

- Collect SOOC jpegs, DT exports, RT exports. A couple of raw files also.
- Ensure they can be copied back.
- inbox.backup is always there.
- 624 megabytes in 55 eligible files.

***  Found

- Canon 5Dm2 SOOC jpegs + a few DT processed ones, plus 1 CR2
- Olympus EPL5 SOOC file and ORF files, and XMP sidecars as clutter
- Fuji XT1 SOOCs
- Pokkari-SOOC
- Leica Q: DT-processed files (with dupes) + DNG + XMP
- M240: dt, rt, dng, sidecars xmp + pp3
** NOTSURE Check out if Metosin muuntaja is useful
CLOSED: [2020-03-15 Sun 18:45]
* Setting up the dev environment                                :emacs:cider:

System:

- Leiningen
- emacs + cider

Set up the deps and libraries:

: lein deps

Connect both at once as the good RMS intended.

: M-x cider-jack-in-clj&cljs

Figwheel-main starts our backend and serves frontend things, and is
running in port 9500 so head to http://localhost:9500 and see the
magic.

** DONE Combining servers
[2020-04-26 Sun]

We've hit several times to the issues that come from running a
figwheel server at port 9500 and then the rest of our clojure code at
port 8088.

Luckily this issue is well known by others too, so there's some help
available.

https://figwheel.org/docs/your_own_server.html

It is unclear whether the trick will exactly allow simultaneous
development of CLJ and CLJS.

Can we route (proxy) requests via figwheel's own server to port 8088?
Now browser ever only interacts with localhost:9500.

What we can do easily is supply the ring-handler so that running
figwheel-main connects to our clurator. Stuff this in for example
=dev.cljs.edn=.

#+BEGIN_EXAMPLE
  :ring-handler clurator.core/app
#+END_EXAMPLE

All good... Just remember to wipe out =server-uri= in core.cljs, so
that we connect to same-domain. The same will go for CSS references
and so on.

But now, what of modifying clurator code?!

Let's jack into the code, not sure what that did actually. Started a
new JVM, hopefully not?

Hmm, seems to work out of the box. Marvelous, so marvelous.

I believe the original =cider-jack-in-clj&cljs= will still do. Let's
try that out.
