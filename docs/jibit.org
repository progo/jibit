Jibit dev documents. May be bilingual.

* Database solution
[2020-02-16 Sun]

Let's study database libraries for Clojure. Relational or not. I'm
gravitating towards a system that would give me basic M2M things but
of course you don't need RDBMS for that.

** SQL
*** HugSQL
https://www.hugsql.org/

Interesting idea about leaving SQL matters for SQL the DSL. Certainly
intriguing because SQL is arguably the best choice for relational
databases, and all ORM type of language translations occasionally
introduce unnecessary complexity.

Very interesting idea but looking into my use cases in my software I'm
not sure how it will handle dynamically applied filters to a query.
Should investigate more closely!

Somewhat both expectedly and disappointingly the solution is to use
HugSQL when it helps the most and drop down to JDBC calls when you
need maximum dynamism.

*** DONE HoneySQL
CLOSED: [2020-02-28 Fri 18:11]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-02-28 Fri 18:11]
:END:
https://github.com/jkk/honeysql

This is a library for building SQL. You'd use =clojure.jdbc= with this.

The big benefit over Korma here is the flexible map-based query
building. It keeps the ORM at minimum, you're basically talking about
SQL but in flexible Clojure terms.

Even so, will it beat real SQL in its home town? Secondly this project
lacks the connection helper utilities (which is proper because other
projects can so easily build on this one).

*** NOTSURE Korma
CLOSED: [2020-02-16 Sun 17:07]
https://github.com/korma/Korma

Korma used to be a big player back in the day. Looking at it now, it
hasn't seen commits in 2 years.

Korma embraces the Lisp approach of macro-based DSLs. It's all fun and
games but the truth is that the newer school of keeping data real data
(as in, maps) has great benefits.

Combine that DSL macro issue with the lack of activity (although
again, I'm sure it has reached maturity and would work 100% perfectly
with my needs) let's say this is not going to be the first choice.

*** DONE Yesql

Yesql has been put on freeze about 3-4 years ago. I'm sure it'll work
perfectly but let's put this bottom of the stack.

But quickly skimming the readme, shows this is actually closely
resembling HugSQL anyway.

*** NOTSURE Toucan
CLOSED: [2020-02-16 Sun 17:03]
https://github.com/metabase/toucan

A high-level SQL engine, so it's more ORM than the rest. Built on
HoneySQL. This is probably not something that I want to explore at
this time.

** Others

These solutions are probably super cool and all, but I need a local,
offline, preferably one-file solution to store everything. This
gravitates me back to Sqlite and thus, SQL.

*** NOTSURE Datomic
CLOSED: [2020-02-16 Sun 17:31]

Datomic would be so sweet, but it's a big overkill. I want to run an
offline, purely local setup.

*** NOTSURE CouchDB + Clutch
CLOSED: [2020-02-16 Sun 17:31]

** Conclusion

Currently I'm thinking, pure JDBC (Sean Corfield's JDBC.next) + HoneySql.

Let's leverage SQL at the database level, creating suitable views as
needed.

* Data schema

A simple schema for a simple CRUD.

We will want to import most of the EXIF informations into the database
for fast and convenient access.

EXIF tags too, but let's leave that for later.

** Structure plans 

- picture
  - id
  - filename
  - original (raw)
  - rating
  - taken_ts
  - developed_ts
  - import_ts
  - title 
  - description
  - width_pixels
  - height_pixels
  - 
- picture_tag
  - id
  - picture_id  (FK)
  - tag_id      (FK)
  - orderno     (*1)
  - rating      (*2)
- tag
  - id
  - title 
  - tag_type    (*4)
  - description
  - parent_tag  (FK)
  - public    boolean
  - color       (*3)
  - style_attrs (*3)

** Schema annotated
*** Photo
[2020-03-01 Sun]

This is going to be a fat table to be sure, but there's not much wrong
here. Camera and lens manufacturer info is in denormalised form here,
I don't see it being a huge problem. It'll be easy to convert into a
more normalised form later on. Or it'll be difficult, but if so, it'll
be difficult to maintain the relations.

- id
- lens_make :: (String) Lens manufacturer. Not very reliable.
- lens_model :: (String) Exif info about the lens used. Can be empty
  for compact cameras but should otherwise always be populated.
- lens_min_fl :: (Num) zoom lens's widest FL. Prime populated both
  with same.
- lens_max_fl :: (Num) zoom lens's narrowest FL. Prime populated both
  with same.
- focal_length :: (Num) FL used for this shot.
- focal_length_35 :: (Num) for convenience reasons normalized FL in
  35mm equiv.
- aperture :: (Num) used aperture opening for the shot, or its
  inverse, meaning that "4" means the aperture of "1/4".
- exposure_comp :: (Num) exposure compensation value if used camera's
  metering.
- camera_make :: (String) manufacturer of the Camera body.
- camera_model :: (String) model of the Camera body.
- iso :: (Num) ISO speed used to take this shot.
- shutter_speed :: (Num) exposure time, or shutter speed in seconds.
  "0.025" means "1/40" and so on.
- light_value :: (Num) Exiftools or possibly the camera's measured
  light value for fun.
- rating :: (Num) user-given rating in Jibit.
- orig_rating :: (Num) The rating that was encoded with EXIF, given in
  camera or in raw editing tool or existing image managing tool.
- taken_ts :: (datetime) when the shot was taken
- process_ts :: (datetime) when the file was processed in a raw editor
  or similar tool.
- import_ts :: (datetime) when the file was imported to Jibit database.
- width :: (num) width of the image in pixels
- height :: (num) height of the image in pixels
- megapixels :: (num) convenience normalization of the image resolution
- title :: (String) user-given title for the image
- subtitle :: (String) user-given secondary title
- description :: (String) any notes and comments and stories about the
  image.
- notes :: (String) personal notes and comments not meant for exported
- original_file  :: (String) the file name of the original file when
  it was imported.
- original_raw :: (String) the location of the raw file the file was
  developed from.
- original_dir :: (String) the name of the directory the file was in,
  when imported.
- uuid :: (String) very unique id 
- storage_filename :: (String) the file name under which the file is
  stored in the file system internally.

** Notes

- 1: If we choose to implement albums using tags, then orderno is
  necessary for adjustment of order. Some places choose to implement
  these two things in separate tables.
- 2: Picture may stand better within a subcontext so it might warrant
  a rating that is only relevant within the tag or album.
- 3: Tag has colors, style (for organisation purposes within Jibit,
  nowhere else). Nested tags shall inherit the parent tag's styling by
  default, but if these colors are defined, they override.
- 4: Not sure if necessary, but flairs and "deletion flags" may
  warrant this kind of type distinction.

** Tag traps

Tagged photos

: select id from photo
: where id in (select photo_id from photo_tag)

Untagged photos

: select id from photo
: where id not in (select photo_id from photo_tag)

Photos tagged with tag id 3

: select photo.*
: from photo
: where id in (select photo_id from photo_tag where tag_id = 3)

Photos tagged with tag named 'Cars' (id 3)

: select photo.*
: from photo
: where id in (select photo_id from photo_tag where tag_id = (select id from tag where name ='Cars'))

Photos tagged with (UNION) tag 1 or 2

: select id from photo
: where id in (select photo_id from photo_tag where tag_id in (1, 2));

Photos tagged with (INTERSECT) tags 2 and 3. Here's the trick is to have count(id) equal to the amount of tags selected. 

#+BEGIN_EXAMPLE
  SELECT p.*
  FROM photo p
  WHERE EXISTS (
    SELECT NULL 
    FROM photo_tag pt 
    JOIN tag        t ON pt.tag_id = t.id
    WHERE t.id IN (2, 3) 
    AND pt.photo_id = p.id 
    GROUP BY pt.photo_id 
    HAVING count(t.id) = 2);
#+END_EXAMPLE

Can also search by other tag properties easily.

#+BEGIN_EXAMPLE
  SELECT p.*
  FROM photo p
  WHERE EXISTS (
    SELECT NULL 
    FROM photo_tag pt 
    JOIN tag        t ON pt.tag_id = t.id
    WHERE t.name IN ('Red', 'Cars') 
    AND pt.photo_id = p.id 
    GROUP BY pt.photo_id 
    HAVING count(t.id) = 2);
#+END_EXAMPLE
* File Storage

- Meaningful names are meaningful but we have a problem with changing
  the names after metadata changes.
- So maybe just UUIDs for file names. UUID + original extension.
- We can write "views" over the data using hard or soft links and
  those files can be named using any available metadata.

* Trolling the drop box                                              :import:
** About sidecars
[2020-02-23 Sun]

I am saying not to care about these at this point. Our current scope
is to manage end results, not the raw files.

** About raw files
[2020-02-23 Sun]

Good point, then. If we are to ignore sidecars then is it only fair to
also ignore raw files?

** NOTSURE Let's ignore raw files for now.
CLOSED: [2020-03-29 Sun 19:32]

See [[rawthumbnail]] and this discussion above about XMP and raw file things.

If we need raw image preview, we can do it. But it is certain other
problems as well. Thumbnail extraction, thumbnails have to be oriented
properly, so rotation things too.

** TODO HEIF, GIF, WEBM

These are all valid things to manage but we probably have to leave
these for later.

* EXIF parsers
** NOTSURE Drew Noakes: metadata-extractor

This tool looks so promising, is simple and everything. Sadly it
appears to be very incomplete wrt support and functionality. We'll
have to turn to the 'industry standard', Phil Harvey's exiftool.

** DONE Phil Harvey: Exiftool and java bindings

- Java integration https://github.com/mjeanroy/exiftool 
  - Can use exiftool's daemon mode that gives us 25x speedup

** NOTSURE What would libexiv2 do for us?
CLOSED: [2020-04-03 Fri 13:56]

- Darktable and company uses this thing instead of exiftool.
- This has an alternative understanding to lens id's among other things.
- (This also explains why aperture readings are different in darktable
  and in some online forums; different exif libraries used.)
- Exiv2 is a C++ tool and quickly googling around it seems there are
  no hugely popular java bindings available.

* NOTSURE Parse images on import for width/height?
CLOSED: [2020-03-01 Sun 19:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-01 Sun 19:54]
:END:

Pure exiftool output isn't enough. Raw files have funky resolutions
sometimes and do we dare to f.ex round up Leica M's 23.85 megapixels
up to 24?

Probably yes, but also no.

On JPEG files exif tags "ImageWidth" and "ImageHeight" seem to be
correct. Since we don't want to concern us with raw files (and the
whole resolution concept is not super clear) let's trust Phil on this
analysis.

* On accuracy of measurements ISO/Aperture/SS/EC

I would say that if we handle 1/3-stops and 1/2-stops decently from
floating point numbers it's accurate enough to be also statistically
useful.

After all, the DOF differences between f/2.76 and f/2.8 aren't going
to be visible. And movement at 1/28 seconds and 1/30 seconds is
equally blurry.

Light value is probably something we can just show with rounded to two
decimal places.

* DONE inbox: fs/expand-home
CLOSED: [2020-03-29 Sun 19:32]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-29 Sun 19:32]
:END:

This thing should really be done once at settings' reading time.

* TODO Our backend API should be stricter with Access-Control-Allow-Origin

Limit it to localhost? And this is naturally something the production
shouldn't need... Since the same URI serves the JS and the API.

Using a wildcard on local dev setup is not a problem. The header
should not be set in "production" to ensure only local same-host
queries get through.

* NOTSURE Fix import inaccuracies
CLOSED: [2020-03-07 Sat 17:21]

First import looks so good! But some things we should/could fix.

** DONE :import_ts
CLOSED: [2020-03-03 Tue 19:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-03 Tue 19:54]
:END:

This info comes as string repr. Make it so that it's the same as taken_ts/process_ts.

** NOTSURE :lens_make for Canon, Oly
CLOSED: [2020-03-29 Sun 19:33]

<<ambiglens>>

Surely there's no row on exif info about this?

There's only vague heuristics we could utilise here. A better
user-driven solution exists.

*** Exif tags that could be stored

- Olympus: "Lens Type" or "Lens ID" has a long human-readable id of
  the lens and make.
- Canon 5D: "Lens Type/ID" field is here as well. But Exiftool can't
  distinguish between Canon 17-35 and a generic Sigma lens here.
  
In both cases an unambiguous analysis is not possible, heuristics
would be needed.

*** Real solution that will work 100 % of the time

We don't make up anything; instead we ask the user to fill in the info.

We have now Cameras and Lenses in their own tables and user should be
able to mass-edit those photos to reflect what he was using at the
time. Or just leave empty.
* TODO Asking user to fill in missing info on import

We can detect missing lens_make, lens_model, ask user to fill in them
at import. Sigma, Tamron, some russian plastic lens... all is possible
then. See [[ambiglens]] for more.

Other tools we need or benefit from:

- Shift/correct taken_ts timezones 
- mass-apply FL, lens info (leica lenses or other dead lenses)

* DONE Normalize lens/camera info?
CLOSED: [2020-03-28 Sat 17:04]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 17:04]
:END:

Things like Lens_make, lens_model, FL_min, FL_max, aperture info could
be served well to be in its own table to help with data fill-in.

* DONE Round up all configuration in one EDN file or something
CLOSED: [2020-03-15 Sun 19:08]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-15 Sun 19:08]
:END:

We have stuff in =clurator.inbox=  for starters.

- db
  
We'll ideally want to have this stuff specified either via env or an
edn file. In this case we can skip CLI arguments.

* TODO Configuration rounded up

Keep EDN in considerations though.

* DONE Fix Thumbnails
CLOSED: [2020-03-28 Sat 10:51]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 10:51]
:END:

Do them on import maybe? 

- We want a way to later on adjust the thumbnail size, redo everything
  in batch

* DONE We need good logging facilities
CLOSED: [2020-03-28 Sat 17:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 17:56]
:END:

Timbre is an old friend, let's set it up.

It's somewhat unmaintained as of today. It works but it's somewhat
hard to configure... Well it's figured out.

The docs are a mess but the "f" variants of logging utilities are
"format" versions. Standard C-style format flags work, with java
dialect.

: (debug "foo" "bar" :fez [2 4 5])
: (debugf "This octal is wicked %o" 42)

* UI things

Have to say, the current [2020-03-28 Sat] color palette is looking
nice. Gold + silver on the front against dark grays on the back.
Bright yellow and red easy to use as warning colors, blue/green easy
to adapt into tags.

* TODO Unit tests
* TODO Tagging photos [88%]
** DONE Show existing tags on photos
CLOSED: [2020-04-05 Sun 13:34]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-05 Sun 13:34]
:END:

Let's pass the IDs alone and let jibit join the labels using full
information.

** DONE Selection of photos from lighttable
CLOSED: [2020-04-06 Mon 19:06]
:LOGBOOK:
- State "DONE"       from "NOTSURE"    [2020-04-10 Fri 11:09]
- State "DONE"       from "TODO"       [2020-04-06 Mon 19:06]
:END:

So basically give the ability to tag a photo... we can postpone
selections for later.

** DONE Tag a photo from UI
CLOSED: [2020-04-11 Sat 12:09]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-11 Sat 12:09]
- State "STARTED"    from "TODO"       [2020-04-10 Fri 11:18]
:END:
** NOTSURE Saving tags
CLOSED: [2020-04-10 Fri 11:19]

What's this actually? We go ahead and persist things to DB the moment
we tag/untag photo(s). That's how it's going to be.

** DONE Making new tags [100%]
CLOSED: [2020-04-12 Sun 13:32]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-12 Sun 13:32]
:END:

We're launching a modal div on top of everything to remind us how
great all modal windows used to be.

Things 

- [X] Some refactoring of data-bound-input may be needed.
- [X] We'll want to show user the name is required (don't let user
  click on the Create if empty)
- [X] On "Create" keep the dialog open while request runs, only close
  it once it was successfully saved.
- [X] Spinner is probably not necessary at this point, see how slow it
  is.
- [X] Use a singular piece of state to denote what is shown. =:state
  :new-tag-dlg= and so on.

** DONE Modifying tags
CLOSED: [2020-04-13 Mon 13:15]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-13 Mon 13:15]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:13]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:13]
:END:

We have a bit of refactoring to unify create/modify tag.

Well frankly we didn't need much at all to refactor!

** DONE Modifying tags, make sure "use color" is on 
CLOSED: [2020-04-13 Mon 13:20]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-13 Mon 13:20]
:END:
** TODO Deleting tags

Put this thing under Modify dialog.

** DONE Don't launch Post req on an empty selection
CLOSED: [2020-04-11 Sat 17:43]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:43]
:END:

* TODO Tag things pt 2 [0/3]
** STARTED Tag parents / hierarchies
:LOGBOOK:
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:02]
:END:

It's persisted on saving new ones.
** TODO Order tags by hierarchy?
** STARTED Tag color 
:LOGBOOK:
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:02]
:END:

It's persisted on saving new ones.
* Currently held states                                                :info:

- nil :: default
- tag-dialog :: modal, tag edit/creation dialog
     
* TODO Modal background : dblclick to turn off
* DONE Check do we need that extra boolean on =data-bound-input=
CLOSED: [2020-04-12 Sun 17:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-12 Sun 17:46]
:END:

Yep, seems like =<input>= element can't be made to imitate a
=<textarea>= quite so easily.

* TODO Make tags div stick (toggleable)

Maybe good to place under a shortcut?

* NOTSURE get-photos could be an effect
CLOSED: [2020-04-12 Sun 13:31]

If we pass all the input to it via arguments. Pure style!

I miscalculated the scope of effects handler. Its result aren't indeed
handled the same way the effects are, so let's not go that way.

* TODO tags-union into predicate form 

Add =?=

* DONE Selections
CLOSED: [2020-04-11 Sat 17:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:40]
:END:

Mousedown selection with a small hold time to select a photo, and then
you should be able to continue selecting by dragging.

But first things first, mousedown activates on a click and now we have
to time how long the user holds.

This is now done but the implementation leaves much to be desired.

** Mouse down, up, click

These three always occur in this order, on an element. Unless you make
it into a drag event...

** DONE When already having selections, make it faster to select more
CLOSED: [2020-04-10 Fri 11:07]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-10 Fri 11:07]
:END:
** DONE Clear selection only if photo set changes
CLOSED: [2020-04-11 Sat 17:30]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:30]
:END:

Should we perhaps keep the intersection of photos selected? Yes...
* DONE Effects and Events
CLOSED: [2020-04-11 Sat 17:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:41]
:END:

We'll have to check how the difference shows, especially when an
effect handler doesn't get cofx like that.

Event handlers and effect handlers are a bit complected right now at
re-frame level so it means we use whatever we need to --
events/handlers even when the behavior is more effect-like. Effects
when we can.

* TODO Streamline photo filtering?                                  :backend:

Tags per photo are currently subqueries (and there's that interesting
bug/condition in there relating debug statements).

To get photos and tags in one query, you join =PHOTO_TAG= and collect
=PHOTO_TAG.TAG_ID=.

- One approach gets you duplicate photo rows but with differing tag
  IDs; use clojure to minify
- Another is to use sqlite's =group_concat= function to produce a
  string representation of the IDs. This approach is probably going to
  be a tiny bit faster but there's no flexibility after we want those
  extra bits of information that we store in the M2M relation
  =PHOTO_TAG=.
* DONE Unify terms in code backend/frontend
CLOSED: [2020-04-04 Sat 13:17]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-04 Sat 13:17]
:END:

- Negatives, photos, images... Just *photo* is good? 
- I guess we can go for "slides" on a "lighttable" in jibit.
  
We could check out the darkroom/lighttable terminology for a hint of
nostalgia to get juices going on.

Let's try to keep "photo" as the common term across the board. Use
"slide" and "lighttable" when talking about the representation.

* DONE [#B] Order-by doesn't update repr if data changes
CLOSED: [2020-04-04 Sat 14:06]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-04 Sat 14:06]
:END:

Never mind, ~<select value="foo">~ does this for us.

* DONE Round up Tags in a rounded div
CLOSED: [2020-04-05 Sun 11:31]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-05 Sun 11:31]
:END:
* TODO Maybe show tiny photo counts per each tag?                      :idea:
* TODO re-pressed

something to do with keys?

* TODO UI: show total exp time                                         :idea:

For example user has selected 5 images that have all been exposed
1/250 sec, the total is 1.25 sec.

* Thumbnails from raws

<<rawthumbnail>>

- Canon CR2: full sized JPEG "PreviewImage"
- Leica Q: full sized JPEG "JpgFromRaw" 
- Leica Q: 1080p JPEG "PreviewImage"
- Leica Q: 720p JPEG "PreviewImage"
- Leica M240: Tiny and medium sized previews "PreviewImage"
- Olympus EPL5: Tiny and large sized previews "PreviewImage" and "ThumbnailImage"

* Misc CLJS/Figwheel things
** Inspect App DB

In CLJS / repl

: re-frame.db/app-db

Alternative tool: ~re-frame-10x~
* NOTSURE Check out if Metosin muuntaja is useful
CLOSED: [2020-03-15 Sun 18:45]
* DONE Prepare real data
CLOSED: [2020-02-22 Sat 17:00]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-02-22 Sat 17:00]
:END:

- Collect SOOC jpegs, DT exports, RT exports. A couple of raw files also.
- Ensure they can be copied back.
- inbox.backup is always there.
- 624 megabytes in 55 eligible files.

**  Found

- Canon 5Dm2 SOOC jpegs + a few DT processed ones, plus 1 CR2
- Olympus EPL5 SOOC file and ORF files, and XMP sidecars as clutter
- Fuji XT1 SOOCs
- Pokkari-SOOC
- Leica Q: DT-processed files (with dupes) + DNG + XMP
- M240: dt, rt, dng, sidecars xmp + pp3
* Setting up the dev environment                                :emacs:cider:

System:

- Leiningen
- emacs + cider

Set up the deps and libraries:

: lein deps

Connect both at once as the good RMS intended.

: M-x cider-jack-in-clj&cljs

In the CLJ repl evaluate =clurator.core= and in that namespace run:

: (def SERV (-main))

Now the server starts at port 8088. Stop the server by running the
bound function =(SERV)=.

And frontend/figwheel things are running in port 9500 so head to
http://localhost:9500 and see the magic.
