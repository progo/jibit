Jibit dev documents. May be bilingual.

* Database solution
[2020-02-16 Sun]

Let's study database libraries for Clojure. Relational or not. I'm
gravitating towards a system that would give me basic M2M things but
of course you don't need RDBMS for that.

** SQL
*** HugSQL
https://www.hugsql.org/

Interesting idea about leaving SQL matters for SQL the DSL. Certainly
intriguing because SQL is arguably the best choice for relational
databases, and all ORM type of language translations occasionally
introduce unnecessary complexity.

Very interesting idea but looking into my use cases in my software I'm
not sure how it will handle dynamically applied filters to a query.
Should investigate more closely!

Somewhat both expectedly and disappointingly the solution is to use
HugSQL when it helps the most and drop down to JDBC calls when you
need maximum dynamism.

*** DONE HoneySQL
CLOSED: [2020-02-28 Fri 18:11]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-02-28 Fri 18:11]
:END:
https://github.com/jkk/honeysql

This is a library for building SQL. You'd use =clojure.jdbc= with this.

The big benefit over Korma here is the flexible map-based query
building. It keeps the ORM at minimum, you're basically talking about
SQL but in flexible Clojure terms.

Even so, will it beat real SQL in its home town? Secondly this project
lacks the connection helper utilities (which is proper because other
projects can so easily build on this one).

*** NOTSURE Korma
CLOSED: [2020-02-16 Sun 17:07]
https://github.com/korma/Korma

Korma used to be a big player back in the day. Looking at it now, it
hasn't seen commits in 2 years.

Korma embraces the Lisp approach of macro-based DSLs. It's all fun and
games but the truth is that the newer school of keeping data real data
(as in, maps) has great benefits.

Combine that DSL macro issue with the lack of activity (although
again, I'm sure it has reached maturity and would work 100% perfectly
with my needs) let's say this is not going to be the first choice.

*** DONE Yesql

Yesql has been put on freeze about 3-4 years ago. I'm sure it'll work
perfectly but let's put this bottom of the stack.

But quickly skimming the readme, shows this is actually closely
resembling HugSQL anyway.

*** NOTSURE Toucan
CLOSED: [2020-02-16 Sun 17:03]
https://github.com/metabase/toucan

A high-level SQL engine, so it's more ORM than the rest. Built on
HoneySQL. This is probably not something that I want to explore at
this time.

** Others

These solutions are probably super cool and all, but I need a local,
offline, preferably one-file solution to store everything. This
gravitates me back to Sqlite and thus, SQL.

*** NOTSURE Datomic
CLOSED: [2020-02-16 Sun 17:31]

Datomic would be so sweet, but it's a big overkill. I want to run an
offline, purely local setup.

*** NOTSURE CouchDB + Clutch
CLOSED: [2020-02-16 Sun 17:31]

** Conclusion

Currently I'm thinking, pure JDBC (Sean Corfield's JDBC.next) + HoneySql.

Let's leverage SQL at the database level, creating suitable views as
needed.

* Data schema

A simple schema for a simple CRUD.

We will want to import most of the EXIF informations into the database
for fast and convenient access.

EXIF tags too, but let's leave that for later.

** Structure plans 

- picture
  - id
  - filename
  - original (raw)
  - rating
  - taken_ts
  - developed_ts
  - import_ts
  - title 
  - description
  - width_pixels
  - height_pixels
  - 
- picture_tag
  - id
  - picture_id  (FK)
  - tag_id      (FK)
  - orderno     (*1)
  - rating      (*2)
- tag
  - id
  - title 
  - tag_type    (*4)
  - description
  - parent_tag  (FK)
  - public    boolean
  - color       (*3)
  - style_attrs (*3)

** Schema annotated
*** Photo
[2020-03-01 Sun]

This is going to be a fat table to be sure, but there's not much wrong
here. Camera and lens manufacturer info is in denormalised form here,
I don't see it being a huge problem. It'll be easy to convert into a
more normalised form later on. Or it'll be difficult, but if so, it'll
be difficult to maintain the relations.

- id
- lens_id :: (Num) fk to Gear
- camera_id :: (Num) FK to Gear
- focal_length :: (Num) FL used for this shot.
- focal_length_35 :: (Num) for convenience reasons normalized FL in
  35mm equiv.
- aperture :: (Num) used aperture opening for the shot, or its
  inverse, meaning that "4" means the aperture of "1/4".
- exposure_comp :: (Num) exposure compensation value if used camera's
  metering.
- iso :: (Num) ISO speed used to take this shot.
- shutter_speed :: (Num) exposure time, or shutter speed in seconds.
  "0.025" means "1/40" and so on.
- light_value :: (Num) Exiftools or possibly the camera's measured
  light value for fun.
- rating :: (Num) user-given rating in Jibit.
- orig_rating :: (Num) The rating that was encoded with EXIF, given in
  camera or in raw editing tool or existing image managing tool.
- taken_ts :: (datetime) when the shot was taken
- process_ts :: (datetime) when the file was processed in a raw editor
  or similar tool.
- import_ts :: (datetime) when the file was imported to Jibit database.
- width :: (num) width of the image in pixels
- height :: (num) height of the image in pixels
- megapixels :: (num) convenience normalization of the image resolution
- title :: (String) user-given title for the image
- subtitle :: (String) user-given secondary title
- description :: (String) any notes and comments and stories about the
  image.
- notes :: (String) personal notes and comments not meant for exported
- is_raw :: (Boolean) whether the file is a raw file or a bitmap like
     JPEG or PNG.
- original_file  :: (String) the file name of the original file when
  it was imported.
- original_raw :: (String) the location of the raw file the file was
  developed from.
- original_dir :: (String) the name of the directory the file was in,
  when imported.
- uuid :: (String) very unique id 
- storage_filename :: (String) the file name under which the file is
  stored in the file system internally.

** Notes

- 1: If we choose to implement albums using tags, then orderno is
  necessary for adjustment of order. Some places choose to implement
  these two things in separate tables.
- 2: Picture may stand better within a subcontext so it might warrant
  a rating that is only relevant within the tag or album.
- 3: Tag has colors, style (for organisation purposes within Jibit,
  nowhere else). Nested tags shall inherit the parent tag's styling by
  default, but if these colors are defined, they override.
- 4: Not sure if necessary, but flairs and "deletion flags" may
  warrant this kind of type distinction.

** Migrations

SQLite doesn't have good migration support for for example if =TAG=
needs new constraints or something, we first have to create the new
table with all the wanted baggage, move the data over and then try to
drop the old one.

The old one will still have some FK constraints in place.

#+BEGIN_EXAMPLE
  -- Migrate/update table "tag" with new constraints.
  create table tag2
  ( id                      integer primary key autoincrement
  , name                    text not null
  , type                    text
  , description             text
  , parent_id               integer
  , style_color             text
  , style_attrs             text
  , public                  integer
  , foreign key (parent_id) references tag(id) on delete restrict on update cascade
                            check (parent_id != id)
  , unique (name)
  );
  drop index ix_tag_name;       --new
  drop index ix_tag_type;       --new
  drop index ix_tag_parent_id;  --new
  create index ix_tag_name on tag2(name);
  create index ix_tag_type on tag2(type);
  create index ix_tag_parent_id on tag2(parent_id);

  insert into tag2 select * from tag;
  commit;

  -- all done

  alter table tag rename to tag_d;
  alter table tag2 rename to tag;
#+END_EXAMPLE

Look at this TechOnTheNet article about a working pattern:

#+BEGIN_EXAMPLE
  PRAGMA foreign_keys=off;

  BEGIN TRANSACTION;

  ALTER TABLE table1 RENAME TO _table1_old;

  CREATE TABLE table1 (
  ( column1 datatype [ NULL | NOT NULL ],
    column2 datatype [ NULL | NOT NULL ],
    ...
  );

  INSERT INTO table1 (column1, column2, ... column_n)
    SELECT column1, column2, ... column_n
    FROM _table1_old;

  COMMIT;

  PRAGMA foreign_keys=on;
#+END_EXAMPLE

** Tag traps

Tagged photos

: select id from photo
: where id in (select photo_id from photo_tag)

Untagged photos

: select id from photo
: where id not in (select photo_id from photo_tag)

Photos tagged with tag id 3

: select photo.*
: from photo
: where id in (select photo_id from photo_tag where tag_id = 3)

Photos tagged with tag named 'Cars' (id 3)

: select photo.*
: from photo
: where id in (select photo_id from photo_tag where tag_id = (select id from tag where name ='Cars'))

Photos tagged with (UNION) tag 1 or 2

: select id from photo
: where id in (select photo_id from photo_tag where tag_id in (1, 2));

Photos tagged with (INTERSECT) tags 2 and 3. Here's the trick is to have count(id) equal to the amount of tags selected. 

#+BEGIN_EXAMPLE
  SELECT p.*
  FROM photo p
  WHERE EXISTS (
    SELECT NULL 
    FROM photo_tag pt 
    JOIN tag        t ON pt.tag_id = t.id
    WHERE t.id IN (2, 3) 
    AND pt.photo_id = p.id 
    GROUP BY pt.photo_id 
    HAVING count(t.id) = 2);
#+END_EXAMPLE

Can also search by other tag properties easily.

#+BEGIN_EXAMPLE
  SELECT p.*
  FROM photo p
  WHERE EXISTS (
    SELECT NULL 
    FROM photo_tag pt 
    JOIN tag        t ON pt.tag_id = t.id
    WHERE t.name IN ('Red', 'Cars') 
    AND pt.photo_id = p.id 
    GROUP BY pt.photo_id 
    HAVING count(t.id) = 2);
#+END_EXAMPLE
* File Storage

- Meaningful names are meaningful but we have a problem with changing
  the names after metadata changes.
- So maybe just UUIDs for file names. UUID + original extension.
- We can write "views" over the data using hard or soft links and
  those files can be named using any available metadata.
* ClojureScript 1.10.741
[2020-04-26 Sun]

- Looks like this new release causes issues with our stack. The
  underlying issue appears to be google closure updates.
  - figwheel

    #+BEGIN_EXAMPLE
      Use of undeclared Var goog.net.XhrIo/send
    #+END_EXAMPLE

  - taoensso.timbre

    #+BEGIN_EXAMPLE
      Compile Warning: Use of undeclared Var goog.structs/Map
    #+END_EXAMPLE

- Fall back to 1.10.597 for time being.
  - Although we started with version 1.10.520
  - Figwheel-main's docs have been updated to mention about this
    problem so expect a solution soon.

* Trolling the drop box                                              :import:
** About sidecars
[2020-02-23 Sun]

I am saying not to care about these at this point. Our current scope
is to manage end results, not the raw files.

** About raw files
[2020-02-23 Sun]

Good point, then. If we are to ignore sidecars then is it only fair to
also ignore raw files?

** NOTSURE Let's ignore raw files for now.
CLOSED: [2020-03-29 Sun 19:32]

See [[rawthumbnail]] and this discussion above about XMP and raw file things.

If we need raw image preview, we can do it. But it is certain other
problems as well. Thumbnail extraction, thumbnails have to be oriented
properly, so rotation things too.

** TODO HEIF, GIF, WEBM

These are all valid things to manage but we probably have to leave
these for later.

** TODO original_raw

My raws right now:

: ~/pics/digikuvat/xyz/foo.raw

Darktable can export files as

: ~/pics/inbox/xyz/foo.jpg

Original raw location can be thus traced via =:original-dir= and
=:original-filename=.

But this requires cooperation from darktable/whatever to work
smoothly. Very specific for my usecase.

* EXIF parsers
** NOTSURE Drew Noakes: metadata-extractor

This tool looks so promising, is simple and everything. Sadly it
appears to be very incomplete wrt support and functionality. We'll
have to turn to the 'industry standard', Phil Harvey's exiftool.

** DONE Phil Harvey: Exiftool and java bindings

- Java integration https://github.com/mjeanroy/exiftool 
  - Can use exiftool's daemon mode that gives us 25x speedup

** NOTSURE What would libexiv2 do for us?
CLOSED: [2020-04-03 Fri 13:56]

- Darktable and company uses this thing instead of exiftool.
- This has an alternative understanding to lens id's among other things.
- (This also explains why aperture readings are different in darktable
  and in some online forums; different exif libraries used.)
- Exiv2 is a C++ tool and quickly googling around it seems there are
  no hugely popular java bindings available.

* NOTSURE Fix import inaccuracies
CLOSED: [2020-03-07 Sat 17:21]

First import looks so good! But some things we should/could fix.

** DONE :import_ts
CLOSED: [2020-03-03 Tue 19:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-03 Tue 19:54]
:END:

This info comes as string repr. Make it so that it's the same as taken_ts/process_ts.

** NOTSURE :lens_make for Canon, Oly
CLOSED: [2020-03-29 Sun 19:33]

<<ambiglens>>

Surely there's no row on exif info about this?

There's only vague heuristics we could utilise here. A better
user-driven solution exists.

*** Exif tags that could be stored

- Olympus: "Lens Type" or "Lens ID" has a long human-readable id of
  the lens and make.
- Canon 5D: "Lens Type/ID" field is here as well. But Exiftool can't
  distinguish between Canon 17-35 and a generic Sigma lens here.
  
In both cases an unambiguous analysis is not possible, heuristics
would be needed.

*** Real solution that will work 100 % of the time

We don't make up anything; instead we ask the user to fill in the info.

We have now Cameras and Lenses in their own tables and user should be
able to mass-edit those photos to reflect what he was using at the
time. Or just leave empty.
* TODO Asking user to fill in missing info on import

We can detect missing lens_make, lens_model, ask user to fill in them
at import. Sigma, Tamron, some russian plastic lens... all is possible
then. See [[ambiglens]] for more.

Other tools we need or benefit from:

- Shift/correct taken_ts timezones 
- mass-apply FL, lens info (leica lenses or other dead lenses)
* TODO Configuration rounded up

Keep EDN in considerations though.

* TODO Unit tests
* TODO Filter panel enhancements [9/9]
** DONE Imported "today/yesterday/this week/all time"
CLOSED: [2020-04-26 Sun 11:17]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-26 Sun 11:17]
:END:

First we do a dumb version, then try to import the date selection
widget for all dates.
** DONE Show untitled
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Show untagged
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Show unrated
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Include raws on/off
CLOSED: [2020-04-25 Sat 14:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 14:47]
:END:
** DONE Enter to launch search
CLOSED: [2020-05-14 Thu 17:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-14 Thu 17:47]
:END:
** DONE Can inputs have a "clear" field natively?
CLOSED: [2020-05-03 Sun 14:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-03 Sun 14:40]
:END:

- Chromium can (input type "search")
- Firefox can't
  
That's now somewhat done using css and shit.
** DONE Toggle filter panel visibility
CLOSED: [2020-05-21 Thu 12:10]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-21 Thu 12:10]
:END:
** DONE Indicate when filters are active
CLOSED: [2020-05-21 Thu 14:59]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-05-21 Thu 14:59]
- State "STARTED"    from              [2020-05-21 Thu 12:10]
:END:
* TODO Photo model: UUID as the only ID?
* DONE Exif on Panasonic GX80
CLOSED: [2020-05-23 Sat 13:19] SCHEDULED: <2020-05-23 Sat>
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-23 Sat 13:19]
:END:

It isn't conveying lens info. Let's see what's what.

The aperture is also 'incorrectly' rounded "5.5" exact.

Standalone Exiftool 11.99 is giving good info about the lens. The java
wrapper is not... Just to make sure, =(.getVersion exiftool)= gives
the same.

Mjeanroy's exiftool wrapper is well equipped with debug statements.
Just have to enable them somehow.

It was sufficient to write a log4j property file and also add any old
version of "log4j" in lein deps...

** Findings
[2020-05-23 Sat]

Panasonic uses field name "LensID" and Exiftool understands that.

#+BEGIN_EXAMPLE
  (~/panasonic-test-material) exiftool -j 2020-05-16-15-50-P1020617.jpg | grep LensID
    "LensID": "Lumix G Vario 35-100mm F4.0-5.6 Asph. Mega OIS",
#+END_EXAMPLE

The same value comes as a numerical value in the wrapper:

#+BEGIN_EXAMPLE
  DEBUG com.thebuzzmedia.exiftool.core.handlers.BaseTagHandler - Read Tag [name=UnspecifiedTag{name: "LensID"}, value=2 23 10]
#+END_EXAMPLE

So does ExifTool in fact own a database of lenses that it queries
things against? Huh. => Oh shit, it's true. Never would have guessed.

** Exiftool

Exiftool makes the "join" from its own database when queried without
"-n" (--printConv). But when prettyformat is applied (-n omitted) the
lens database join is performed.

We'll have to google and see what the Author has to say.

** Findings cont'd
[2020-05-26 Tue]

From today's analysis I conclude that the Wrapper is doing a good job.
It's calling Exiftool with =-n= but there are so many ways to neatly
affect how the library invokes E, it wouldn't have been a big burden
to implement custom behavior. Nevertheless, we are close to the
"metal" (command-line) currently which is not too terrible either.

* DONE Tag creation: Enter on Tag name to create it immediately
CLOSED: [2020-05-14 Thu 17:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-14 Thu 17:47]
:END:
* DONE Projector: load up all photos on the table to allow browsing
CLOSED: [2020-05-13 Wed 18:25]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-13 Wed 18:25]
:END:
* DONE [#A] Is tagging working at the moment?
CLOSED: [2020-05-03 Sun 14:52]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-03 Sun 14:52]
:END:

Reagent components and closures are a bit confusing, hence the issue.
Should study more about them, and subscriptions. Apparently there's a
good amount of things that don't work quite out of the box as one'd
hope.

* DONE Fancy date selector
CLOSED: [2020-05-01 Fri 13:57]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-05-01 Fri 13:57]
- State "STARTED"    from "TODO"       [2020-05-01 Fri 10:58]
:END:

We should build a date selector that has a couple of ways to interact,
and provide some default ranges.

- "today"
- "yesterday"
- "this week"
- "this month"
- between dt-dt

* DONE Comboboxes natively
CLOSED: [2020-05-02 Sat 18:19]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-05-02 Sat 18:19]
- State "STARTED"    from "TODO"       [2020-05-02 Sat 17:48]
:END:

Input + datalist is a thing actually.

The simple native solution works rather beautifully for our simple case.

* TODO Metadata tools in a menu [0/2]

These should work on the selection.

** TODO Adjust "taken" time by shifting hours on selected
** TODO Replace Lens used

Search/replace kind of a deal?

* TODO Import multithreaded

Currently on my old 4-core system where I run thing single-threaded,
load average is around 2.3--2.7.

Means we could easily double and get meaningful throughput. And this
is also embarrassingly parallelizable stuff.

* DONE Gear editor
CLOSED: [2020-05-11 Mon 16:52]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-05-11 Mon 16:52]
- State "STARTED"    from "TODO"       [2020-05-04 Mon 12:23]
:END:

# Let's do a handcrafted grid table editor for starters. Something like
# what ExtJS does would be fine but quick search didn't result in a
# handy standalone library.

Or first let's have a look-see about [[http://tabulator.info/][Tabulator]]. This thing could be
used for other things as well in the future!

The idea is to present a dumb dumb list of gear from database as such:

| Type   | Exif Make        | Exif Model    | Label            |   |
|--------+------------------+---------------+------------------+---|
| Lens   | Canon            | EF4028        | EF 40mm f/2.8    |   |
| Lens   | Canon            | EF17-40f4     | Sigma 20mm       |   |
| Camera | CANON CAMERA INC | EOS5D MARK II | Canon 5D Mark II |   |
| Camera | FUJIFILM         | FUJIFILM X-T1 | Fujifilm X-T1    |   |

Exif make, model come from the exiftool's data and cannot be changed.
But this data can be ugly and it's not uniform across manufacturers,
hence we let the user name the gear in that "Label" column which is
editable.

In the future maybe allow lenses to have aperture and FL information
too.

** In JS

Define sample data. (Tabulator doesn't like constants so =let= is not
working here: it is after all updating the data on the fly as the user
modifies cells.)

#+BEGIN_EXAMPLE
var D = [{ id: 1, gear_type: "Camera", exif_make: "Canon", exif_model: "5D Mark 2" }
        ,{ id: 2, gear_type: "Camera", exif_make: "Canon", exif_model: "6D" }
        ,{ id: 3, gear_type: "Lens",   exif_make: "Canon", exif_model: "EF35mm f/1.4L USM" }
        ,{ id: 4, gear_type: "Camera", exif_make: "Fujifilm", exif_model: "X-Pro2" }
        ,{ id: 5, gear_type: "Lens",   exif_make: "LEICA CAMERA AG", exif_model: "Summicron 35 mm f/2 ASPH" }
        ,{ id: 6, gear_type: "Camera", exif_make: "Leica Camera AG", exif_model: "Leica Q (Typ 116)" }
        ,{ id: 7, gear_type: "Camera", exif_make: "LEICA CAMERA AG", exif_model: "Leica M (Typ 240)" }
];
#+END_EXAMPLE

Define table generation code

#+BEGIN_EXAMPLE
new Tabulator ( "#gear-table", {  data: D, height: 256, columns: [
  { title: "Type", field: "gear_type", width: 80 }
, { title: "EXIF Make", field: "exif_make", width: 200 }
, { title: "EXIF Model", field: "exif_model", width: 200 }
, { title: "Label", field: "user_label", width: 200, editor:"input" }]});
#+END_EXAMPLE

** DONE Implement saving of user labels
CLOSED: [2020-05-07 Thu 20:25]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-07 Thu 20:25]
:END:
** DONE Make a view unifying the gear on DB level and issue queries against that
CLOSED: [2020-05-07 Thu 19:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-07 Thu 19:47]
:END:

Terrible thing, writing legacy code from the beginning. Let's do better.

** DONE Make user_label used everywhere
CLOSED: [2020-05-11 Mon 16:51]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-11 Mon 16:51]
:END:

There's also now user_make, user_model if we want to allow structured
modifications.

** NOTSURE Photo map -> gear map
CLOSED: [2020-05-10 Sun 11:36]

Backing out of qualified-keyworded maps means some extra work for us
now, better keep this in mind later on.

Let's instead join things in frontend as we have full gear in browser.
Photo query no longer needs to send this information in the query.

** DONE Don't send gear data in get-photos?
CLOSED: [2020-05-11 Mon 16:50]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-11 Mon 16:50]
:END:
** DONE One might still question whether separate tables for Camera, Lens make sense
CLOSED: [2020-05-09 Sat 13:04]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-09 Sat 13:04]
:END:

Let's do this. They're now combined.

** DONE Bypassing the sub model in =(flatten-gear-list)= is a terrible offense
CLOSED: [2020-05-10 Sun 10:53]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-10 Sun 10:53]
:END:

Experiment with the inner/outer pattern:

https://github.com/day8/re-frame/blob/master/docs/Using-Stateful-JS-Components.md

Luckily it played ball quite easily.

Not sure why the =(reagent/argv cmp)= is necessary but it only worked
intermittently when passing the data directly as an argument.

* DONE Tagging photos [100%]
CLOSED: [2020-04-20 Mon 18:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:03]
:END:
** DONE Show existing tags on photos
CLOSED: [2020-04-05 Sun 13:34]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-05 Sun 13:34]
:END:

Let's pass the IDs alone and let jibit join the labels using full
information.

** DONE Selection of photos from lighttable
CLOSED: [2020-04-06 Mon 19:06]
:LOGBOOK:
- State "DONE"       from "NOTSURE"    [2020-04-10 Fri 11:09]
- State "DONE"       from "TODO"       [2020-04-06 Mon 19:06]
:END:

So basically give the ability to tag a photo... we can postpone
selections for later.

** DONE Tag a photo from UI
CLOSED: [2020-04-11 Sat 12:09]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-11 Sat 12:09]
- State "STARTED"    from "TODO"       [2020-04-10 Fri 11:18]
:END:
** NOTSURE Saving tags
CLOSED: [2020-04-10 Fri 11:19]

What's this actually? We go ahead and persist things to DB the moment
we tag/untag photo(s). That's how it's going to be.

** DONE Making new tags [100%]
CLOSED: [2020-04-12 Sun 13:32]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-12 Sun 13:32]
:END:

We're launching a modal div on top of everything to remind us how
great all modal windows used to be.

Things 

- [X] Some refactoring of data-bound-input may be needed.
- [X] We'll want to show user the name is required (don't let user
  click on the Create if empty)
- [X] On "Create" keep the dialog open while request runs, only close
  it once it was successfully saved.
- [X] Spinner is probably not necessary at this point, see how slow it
  is.
- [X] Use a singular piece of state to denote what is shown. =:state
  :new-tag-dlg= and so on.

** DONE Modifying tags
CLOSED: [2020-04-13 Mon 13:15]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-13 Mon 13:15]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:13]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:13]
:END:

We have a bit of refactoring to unify create/modify tag.

Well frankly we didn't need much at all to refactor!

** DONE Modifying tags, make sure "use color" is on 
CLOSED: [2020-04-13 Mon 13:20]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-13 Mon 13:20]
:END:
** DONE Deleting tags
CLOSED: [2020-04-19 Sun 18:39]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-19 Sun 18:39]
- State "STARTED"    from "TODO"       [2020-04-18 Sat 11:09]
:END:

Put this thing under Modify dialog.

- [X] Deleting a tag, enforce tagged items (set null but ask)
- [X] Deleting a tag, enforce parent relation (set null but ask)
- [X] Confirm deleting a tag beforehands

** DONE Tag relations: don't let tag be its own parent
CLOSED: [2020-04-14 Tue 19:35]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-14 Tue 19:35]
:END:

- [X] db constraint?
- [X] ui check definitely

** DONE Cyclical tag ancestors
CLOSED: [2020-04-15 Wed 20:07]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-15 Wed 20:07]
:END:

Cyclic relations can be prohibited during pre-save with this.

| id | pid | tag              |
|----+-----+------------------|
|  1 |     | Cars             |
|  2 |   1 | -- Old Cars      |
|  3 |   1 | -- Red Cars      |
| 66 |   3 | ---- Maroon Cars |
|  4 |     | Blue             |
|  5 |     | Green            |
|  6 |   5 | -- Forest Green  |

Tag 1 (Cars) can't have pid 2, 3 or 66. Tag 5 can't have pid of 6. So
it's the set of all children (descendants) that's verboten.

But tag 66 (Maroon Cars) can be updated to have pid of 1 -- no
restrictions.

So this wishywashy reasoning leaves us to implement a check for
children. Get all descendants as a set and make sure pid is not in
that set.

** DONE Don't launch Post req on an empty selection
CLOSED: [2020-04-11 Sat 17:43]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:43]
:END:

** DONE UI enhancements on Tag Color selection
CLOSED: [2020-04-20 Mon 18:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:03]
:END:

- [X] If user deselects "Use color" checkbox, clear the color from
  colorselector
- [X] If user selects a color using the selector, select "Use color"
  automatically
  
We can bind these to an "on click" event for better or worse.
** DONE Tag parents / hierarchies
CLOSED: [2020-04-14 Tue 16:58]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-14 Tue 16:58]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:02]
:END:

It's persisted on saving new ones.
** DONE Order tags by hierarchy?
CLOSED: [2020-04-14 Tue 18:16]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-14 Tue 18:16]
- State "STARTED"    from "TODO"       [2020-04-14 Tue 17:26]
:END:

** DONE Tag color 
CLOSED: [2020-04-14 Tue 17:24]
:LOGBOOK:
- State "DONE"       from "STARTED"    [2020-04-14 Tue 17:24]
- State "STARTED"    from "TODO"       [2020-04-13 Mon 11:02]
:END:

It's persisted on saving new ones.

If tag has no color, we need to query parent tag for color info, if
there's some.

In our sample data, Cyan (#16) has parent Blue (#1) and should derive
Blue's color. Tag "Nameless" #18 has color of its own and should keep
it.

This inherited color is stored separately as =:tag/computed_color= to
avoid mixing user-given and computed data.

* DONE Human shutter speed of "1 sec" shows wrong
CLOSED: [2020-05-11 Mon 16:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-11 Mon 16:57]
:END:

Probably  all times >= 1 sec are shown incorrectly.

* DONE Move http server parts of =clurator.core= elsewhere
CLOSED: [2020-05-17 Sun 16:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-17 Sun 16:28]
:END:

Moved both parts outside, core has the CLI handling right now.

* TODO Work on Import [9/9]                                          :import:

- [X] CLI interaction/launcher to start import
- [X] Speedy shutdown after CLI invocation has processed everything
- [X] Clean the empty dirs on inbox after import.

  We'll move them under =inbox.processed=
- [X] Notify / mark DB during import. This way UI can be notified.
  Doesn't have to be in DB, a simple atom will do perfectly fine as
  well.

  We don't need this right away if user always activates sync or
  import from the UI.

  But if there was a background batch job or a dir watch, then we'd
  need this.
  
  Mark this as 'done' and make a separate entry.
- [X] Import logs
  When imports have happened, what / how many files were imported
  
  This is basically not very useful because those files are in DB,
  ready for querying.
- [X] Set up listening/polling system (inotify)
  
  =juxt/dirwatch= seems appropriate. But the appearance of a file in
  the inbox is not atomic when it comes to Darktable export.

- [X] Manual sync inbox button

- [X] Message about how many pics were imported

- [X] Manual import button on UI side

  DnD target of course makes sense but we have to make it halfway
  without ability to test right away.

** NOTSURE Watch realtime modifications
CLOSED: [2020-05-31 Sun 12:33]

: juxt/dirwatcher

is pretty alright. It uses callbacks and the function receives
following kinds of maps.

#+BEGIN_EXAMPLE
  ;; touch
  {:file #object[java.io.File 0x6c263ab "/home/progo/pics/inbox/HelloWorld.txt"], :count 1, :action :modify}

  ;; rm
  {:file #object[java.io.File 0x32d58a08 "/home/progo/pics/inbox/HelloWorld.txt"], :count 1, :action :delete}
#+END_EXAMPLE

Darktable export while watching. I exported two pics and this is the
amount of callbacks generated.

#+BEGIN_EXAMPLE
  {:file #object[java.io.File 0x2d90a1e8 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 1, :action :create}
  {:file #object[java.io.File 0x6cadabd3 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 1, :action :modify}
  {:file #object[java.io.File 0x61f8ca28 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 1, :action :modify}
  {:file #object[java.io.File 0x75bc756f "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 4, :action :modify}
  {:file #object[java.io.File 0x65c752cf "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 6, :action :modify}
  {:file #object[java.io.File 0x5d8b05d1 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 2, :action :modify}
  {:file #object[java.io.File 0x20c5c013 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 1, :action :modify}
  {:file #object[java.io.File 0xd7085d2 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 3, :action :modify}
  {:file #object[java.io.File 0x36a1e775 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 9, :action :modify}
  {:file #object[java.io.File 0xc82549c "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 17, :action :modify}
  {:file #object[java.io.File 0x112fc203 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 14, :action :modify}
  {:file #object[java.io.File 0xc301f7f "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-15-47-MP009016.jpg"], :count 2, :action :modify}
  
  -- another file

  {:file #object[java.io.File 0x4ea1bbc3 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 1, :action :create}
  {:file #object[java.io.File 0x7d9dedfa "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 1, :action :modify}
  {:file #object[java.io.File 0x40ea3f5c "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 2, :action :modify}
  {:file #object[java.io.File 0x479ded2a "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 4, :action :modify}
  {:file #object[java.io.File 0x7949e27b "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 4, :action :modify}
  {:file #object[java.io.File 0x3980f86a "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 4, :action :modify}
  {:file #object[java.io.File 0x1619088b "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 5, :action :modify}
  {:file #object[java.io.File 0x2be0309d "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 2, :action :modify}
  {:file #object[java.io.File 0x55a5d628 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 1, :action :modify}
  {:file #object[java.io.File 0xc6b4f76 "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 1, :action :modify}
  {:file #object[java.io.File 0x44a4031f "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 12, :action :modify}
  {:file #object[java.io.File 0x2437076c "/home/progo/pics/inbox/2020-05-30(Sat)-munkkiniemi/2020-05-30-16-15-MP009019.jpg"], :count 43, :action :modify}
#+END_EXAMPLE

For one action of 'create' a multitude of 'modify' actions follow. Now
what? A tough export might take seconds to complete.

Let's leave this thing on the backburner for now. Let's instead make
sure that import routines are easily called from the UI by the user.

** TODO Notify UI when importing

A simple atom in backend plus an API point* will do perfectly fine as
well. We don't need this right away if user always activates sync or
import from the UI. But if there was a background batch job or a dir
watch, *then we'd need this*.

(*) A constant query from the server wouldn't be too fancy. Websockets
maybe.

** TODO Drag'n'Drop support in the upper right corner
* TODO Import file robustness issues
** TODO some basic PNG files and whatnot cause problems at exif analysis
** TODO Problems when inbox.processed already has similar-named files

On conflict rename the new file, okay?
** DONE Finish the Import button ux
CLOSED: [2020-06-02 Tue 18:35]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-06-02 Tue 18:35]
:END:

- [X] Show spinner when doing
- [X] Show import count when done.

* TODO When tag is deleted, phantom little divs remain

Deletion of a tag is not a commonly occuring case so perhaps we can
work around this apparent bug by redoing the lighttable contents
altogether?

* DONE Don't flash the Spinner so quickly
CLOSED: [2020-06-06 Sat 12:04]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-06-06 Sat 12:04]
:END:

When spinner gets disabled make sure we show it for at least 500 ms.

A quick flashing of the spinner is not that user friendly.

We can solve this by always showing a nonmodal message after the
spinning is done spinning.

* TODO Refactor :active-filters and :get-photos to use same basis
* DONE Date filters aren't working
CLOSED: [2020-05-17 Sun 17:03]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-17 Sun 17:03]
:END:

At least "import" is not working correctly anything right now,
resulting in an empty qs.

We use date granularity; since sqlite has these values down to the
millisecond they aren't included in any resultset for this reason.

* TODO Some shutter speeds probably don't render too well.

Leica does what it does but there are some other manufacturers with
more flexible speeds...

Study what some of the cameras (Oly, Pana, Nikon, Canon) allow to do
and see how they are expressed in fractions.

* DONE Lens-id filter isn't working
CLOSED: [2020-05-21 Thu 14:58]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-21 Thu 14:58]
:END:

Space causes issues. Let's trim that away!

* TODO Mark tag as "final" 

If a tag is being treated as an album, some albums may be of the sort
that are finished by some time and then never altered. Contests and
whatnot. If that's the case we might do well if we can mark a tag so
that no more photos can be tagged with it.
* TODO Move "filter/get photos" button to the top bar

Something like "apply filters" or something.
* DONE Mark kebab-case words as full words                            :emacs:

Searches using * or # are not satisfactory because Emacs selects only
one part of the identifier. This is a solved problem so get looking.

People with the same issue: 
- https://github.com/emacs-evil/evil/issues/360
  
So let's push =evil-symbol-word-search= to =t= either globally or in
clojure mode.

This has effects in f.ex org-mode as well, probably not very harmful.

* DONE Code tags, go to definition?                                   :emacs:

Does CIDER help us with this? I want to jump to function definitions.

: cider-find-var

* NOTSURE Automatic tags on import and "system tags"?
CLOSED: [2020-04-27 Mon 18:32]

- Some of the exif /might/ be useful to have as tags so that it's
  possible to exclude that stuff.
- Then again, it'll introduce a lot of things... perhaps not desired?
  
But we definitely need a way to mass-tag and mass-edit photos by gear,
edit their lens data for example. For that kind of things we have
means to do so with taggings.

But the problem is then that we have an excessive amount of tags to an
image and all that...

This is a nonstarter perhaps, because we have separate fields for that
info in the schema, better go that way? (Or we refactor once more?)

** I like the idea about automatically given "unprocessed" tag

You'd have a good view of pics that haven't been processed by you.

Then again, we have "unrated", "untagged", "untitled" so.

* TODO Image name, rating, description fields

We have to think about the UI for this.

* TODO Inspect lighttable/slide performance [1/2]               :performance:
** DONE Issue #1: Selections delay
CLOSED: [2020-05-17 Sun 18:42]
:LOGBOOK:
- State "DONE"       from              [2020-05-17 Sun 18:42]
:END:

Selecting a slide makes about 100 ms or 80 ms optimized and that's
quite a bit. Our render is only 55 slides at the moment so expect a
much worse time in the future.

- Removing the tag labels: no particular effect
- Removing moment.js: no particular effect
  
The large problem was the selection model: make one selection and the
entire grid is redrawn.

I introduced a new selection sub that listens to one particular photo
ID being selected, now the delay is greatly reduced.

** TODO Issue #2: Big populations take a long while

A queryset of >500 photos can introduce a 1+ second delay during which
things appear to be hanging. Very un-HTML-like behavior.

* TODO re-frame and multi-arity event handlers?

https://stuartsierra.com/2015/06/01/clojure-donts-optional-arguments-with-varargs

What we used in =:delete-tag= is an antipattern to Stu Sierra so let's
spend a moment to see if re-frame event handlers allow for a better
way.

* TODO Photo insert things from db to model.photo          :backend:refactor:

And we have this bipolar difference in terminology... can we simplify
it, rid of it?

* TODO Tri-state or N-state toggle buttons?                              :ui:

They're built with a seq of keywords-label pairs, plus input where it
binds the selection. Would work nicely for a few cases in our ui.

But where exactly did we need one?

Maybe here:

- Show photos
  - Raw
  - Cooked
  - All

* Currently held states                                                :info:

: (:state db)

Is a stack that we operate with =conj=, =pop= and =peek=.

- nil :: default
- tag-dialog :: modal, tag edit/creation dialog
- modal-prompt :: modal, generic prompter
     
* Naming conventions                                                   :info:

- Boolean vars should always end in ?
- Vars pointing to "counts" like "photo-count" should be ended with #

* NOTSURE Modal background : dblclick to turn off
CLOSED: [2020-04-25 Sat 12:57]
* TODO Make tags div stick (toggleable)

Maybe good to place under a shortcut?

* TODO What can be done for the dual-confirmation of tag deletion?       :ui:

Two dialogs doesn't look that good. What could be done?

We can absolutely combine the two confirmations in one. Now the first
run will be a "dry run", collecting the potential trouble and then we
confirm regardless of found trouble.

* TODO Slide visual work                                                 :ui:
** TODO Raw indication: show another div over the thumbnail

This div can use all kinds of cool background styles to fade out the raw thumbnail.

** TODO Film slide look?
** TODO Info/details are useless?

* DONE Short messages that show for 2 sec                                :ui:
CLOSED: [2020-06-01 Mon 17:50]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-06-01 Mon 17:50]
:END:

One place where we could use one: when trying to open up a raw file
and we won't do it. (event =:show-photo=)

* TODO Tag list as a tree or a list                                 :ui:tags:

- We show currently tags as a list (but ordered so that subtags are
  grouped together)
- Alternative view that takes more space might be cool: tree form
  where subtags are indented off from the supertag 

* TODO Streamline photo filtering?                                  :backend:

Tags per photo are currently subqueries (and there's that interesting
bug/condition in there relating debug statements).

To get photos and tags in one query, you join =PHOTO_TAG= and collect
=PHOTO_TAG.TAG_ID=.

- One approach gets you duplicate photo rows but with differing tag
  IDs; use clojure to minify
- Another is to use sqlite's =group_concat= function to produce a
  string representation of the IDs. This approach is probably going to
  be a tiny bit faster but there's no flexibility after we want those
  extra bits of information that we store in the M2M relation
  =PHOTO_TAG=.
* TODO Maybe show tiny photo counts per each tag?                      :idea:
* TODO re-pressed

https://github.com/gadfly361/re-pressed

Looks like a solid idea. It manages keyboard events. Probably more
than beneficial.

Added in project deps, experimentation to follow later on.

* TODO UI: show total exp time                                         :idea:

For example user has selected 5 images that have all been exposed
1/250 sec, the total is 1.25 sec.

Let's definitely bake this into when we make little "stats" from selections.

This stats idea would contain things like:

- tag cloud, frequencies
- used FLs, apertures
- used cameras, lenses
- and yes, total exposure time in seconds, minutes, hours?!

* Thumbnails from raws

<<rawthumbnail>>

- Canon CR2: full sized JPEG "PreviewImage"
- Leica Q: full sized JPEG "JpgFromRaw" 
- Leica Q: 1080p JPEG "PreviewImage"
- Leica Q: 720p JPEG "PreviewImage"
- Leica M240: Tiny and medium sized previews "PreviewImage"
- Olympus EPL5: Tiny and large sized previews "PreviewImage" and "ThumbnailImage"

* Misc CLJS/Figwheel things
** Inspect App DB

In CLJS / repl

: re-frame.db/app-db

Alternative tool: ~re-frame-10x~
* Mundane things done
** DONE rename =toggle-button=
CLOSED: [2020-04-17 Fri 18:20]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-17 Fri 18:20]
:END:

Maybe move all data-bound buttons outside
** DONE Check do we need that extra boolean on =data-bound-input=
CLOSED: [2020-04-12 Sun 17:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-12 Sun 17:46]
:END:

Yep, seems like =<input>= element can't be made to imitate a
=<textarea>= quite so easily.

** DONE Refactor error messaging / route handling                  :backend:
CLOSED: [2020-04-17 Fri 17:43]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-17 Fri 17:43]
:END:

As the first thing we need to be sending correct status code when
things go south. The messages and that can be considered later.

Also =create-update-new-tag= needs to move over some place else.

There should be a common protocol about what a route handler's
response should look like.

Minimalistic approach for starters, room to expand?

#+BEGIN_EXAMPLE
  {:status :ok
   :response 'edn-formatted}
#+END_EXAMPLE

And a route handler looks like...

#+BEGIN_EXAMPLE
  (defn xyz [req]
   (let [{code :status-code, resp :response} (xyz-handler req)]
    {:status code
     :headers edn-headers
     :body (prn-str resp)}))
#+END_EXAMPLE

Pretty unified.

Status code can be a number but we don't probs need others than 200 and 500.

** NOTSURE get-photos could be an effect
CLOSED: [2020-04-12 Sun 13:31]

If we pass all the input to it via arguments. Pure style!

I miscalculated the scope of effects handler. Its result aren't indeed
handled the same way the effects are, so let's not go that way.

** DONE Effects and Events
CLOSED: [2020-04-11 Sat 17:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:41]
:END:

We'll have to check how the difference shows, especially when an
effect handler doesn't get cofx like that.

Event handlers and effect handlers are a bit complected right now at
re-frame level so it means we use whatever we need to --
events/handlers even when the behavior is more effect-like. Effects
when we can.

** DONE tags-union into predicate form 
CLOSED: [2020-04-20 Mon 18:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:14]
:END:

Add =?=

** DONE Unify terms in code backend/frontend
CLOSED: [2020-04-04 Sat 13:17]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-04 Sat 13:17]
:END:

- Negatives, photos, images... Just *photo* is good? 
- I guess we can go for "slides" on a "lighttable" in jibit.
  
We could check out the darkroom/lighttable terminology for a hint of
nostalgia to get juices going on.

Let's try to keep "photo" as the common term across the board. Use
"slide" and "lighttable" when talking about the representation.

** DONE [#B] Order-by doesn't update repr if data changes
CLOSED: [2020-04-04 Sat 14:06]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-04 Sat 14:06]
:END:

Never mind, ~<select value="foo">~ does this for us.

** DONE Round up Tags in a rounded div
CLOSED: [2020-04-05 Sun 11:31]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-05 Sun 11:31]
:END:
** DONE inbox: fs/expand-home
CLOSED: [2020-03-29 Sun 19:32]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-29 Sun 19:32]
:END:

This thing should really be done once at settings' reading time.

** DONE Normalize lens/camera info?
CLOSED: [2020-03-28 Sat 17:04]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 17:04]
:END:

Things like Lens_make, lens_model, FL_min, FL_max, aperture info could
be served well to be in its own table to help with data fill-in.

** DONE Fix Thumbnails
CLOSED: [2020-03-28 Sat 10:51]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 10:51]
:END:

Do them on import maybe? 

- We want a way to later on adjust the thumbnail size, redo everything
  in batch

** DONE We need good logging facilities
CLOSED: [2020-03-28 Sat 17:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-28 Sat 17:56]
:END:

Timbre is an old friend, let's set it up.

It's somewhat unmaintained as of today. It works but it's somewhat
hard to configure... Well it's figured out.

The docs are a mess but the "f" variants of logging utilities are
"format" versions. Standard C-style format flags work, with java
dialect.

: (debug "foo" "bar" :fez [2 4 5])
: (debugf "This octal is wicked %o" 42)

** UI things

Have to say, the current [2020-03-28 Sat] color palette is looking
nice. Gold + silver on the front against dark grays on the back.
Bright yellow and red easy to use as warning colors, blue/green easy
to adapt into tags.

** DONE Rename =:cancel-create-tag-dlg=                             :rename:
CLOSED: [2020-04-20 Mon 17:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 17:46]
:END:
** DONE =:open-prompt= -> =:show-prompt=                            :rename:
CLOSED: [2020-04-20 Mon 18:05]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-20 Mon 18:05]
:END:
** DONE Prepare real data
CLOSED: [2020-02-22 Sat 17:00]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-02-22 Sat 17:00]
:END:

- Collect SOOC jpegs, DT exports, RT exports. A couple of raw files also.
- Ensure they can be copied back.
- inbox.backup is always there.
- 624 megabytes in 55 eligible files.

***  Found

- Canon 5Dm2 SOOC jpegs + a few DT processed ones, plus 1 CR2
- Olympus EPL5 SOOC file and ORF files, and XMP sidecars as clutter
- Fuji XT1 SOOCs
- Pokkari-SOOC
- Leica Q: DT-processed files (with dupes) + DNG + XMP
- M240: dt, rt, dng, sidecars xmp + pp3
** NOTSURE Check out if Metosin muuntaja is useful
CLOSED: [2020-03-15 Sun 18:45]
** DONE On click, show image FS
CLOSED: [2020-04-24 Fri 18:34]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-24 Fri 18:34]
:END:

Let's take that good image gallery plugin into the mix. PhotoSwipe is
the name.

*** Problems with setting this up

Could be something about React's nature. Separate little things with
CLJS but they're somewhat solved.

This is the current problem:

#+BEGIN_EXAMPLE
  Uncaught DOMException: Failed to execute 'insertBefore' on 'Node': The
  node before which the new node is to be inserted is not a child of
  this node.

    at PhotoSwipe._applyNavBarGaps (http://localhost:9500/cljs-out/dev/cljsjs/photoswipe/development/photoswipe-ui-default.inc.js:351:17)
#+END_EXAMPLE

The line of code in question:

#+BEGIN_SRC js
  _controls.insertBefore(_fakeCaptionContainer, _captionContainer);
#+END_SRC

Where =_controls= points to the div with classes =pswp__ui
pswp__ui--hidden pswp__ui--one-slide=.

This line of error is usually attributed to ReactJS.

**** DONE Bypassed this problem by bypassing making it a React component

So it's plain elements in =index.html= now. Maybe not as elegant but
it's working seamlessly. This is because this library behaves
functionally and very well, doesn't cause distractions. Especially in
my use currently when I don't need that slide show capability.

We /may/ need to revisit this thing later on, but I don't think
current bypassed "hack" is particularly ugly in isolation, nor will
cause trouble.

**** DONE Google about PhotoSwipe + ReactJS 

Nothing interesting

** DONE Image show: disallow raw files                                  :ui:
CLOSED: [2020-04-25 Sat 11:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-25 Sat 11:41]
:END:

We are not going to render raw files by ourselves right now, so what
should happen is that the interface should know photo being
cooked/uncooked (raw).

We should also mark it in the slide if photo is a raw.

** DONE Tags as a map in db?                             :small:refactor:ui:
CLOSED: [2020-05-11 Mon 17:06]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-11 Mon 17:06]
:END:

It's a smart format for tags to be in anyway, maybe we should store
them as an ID:TAG map in the first place?

*** We can get rid of a few linear searches now
** DONE Selections
CLOSED: [2020-04-11 Sat 17:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:40]
:END:

Mousedown selection with a small hold time to select a photo, and then
you should be able to continue selecting by dragging.

But first things first, mousedown activates on a click and now we have
to time how long the user holds.

This is now done but the implementation leaves much to be desired.

*** Mouse down, up, click

These three always occur in this order, on an element. Unless you make
it into a drag event...

*** DONE When already having selections, make it faster to select more
CLOSED: [2020-04-10 Fri 11:07]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-10 Fri 11:07]
:END:
*** DONE Clear selection only if photo set changes
CLOSED: [2020-04-11 Sat 17:30]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-11 Sat 17:30]
:END:

Should we perhaps keep the intersection of photos selected? Yes...
** DONE Round up all configuration in one EDN file or something
CLOSED: [2020-03-15 Sun 19:08]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-15 Sun 19:08]
:END:

We have stuff in =clurator.inbox=  for starters.

- db
  
We'll ideally want to have this stuff specified either via env or an
edn file. In this case we can skip CLI arguments.

** DONE "keywordify" is twice implemented
CLOSED: [2020-05-09 Sat 12:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-09 Sat 12:14]
:END:

Once in =exif.clj= and more recently in =view.gear=

** DONE Our backend API should be stricter with Access-Control-Allow-Origin
CLOSED: [2020-04-26 Sun 13:05]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-04-26 Sun 13:05]
:END:

Limit it to localhost? And this is naturally something the production
shouldn't need... Since the same URI serves the JS and the API.

Using a wildcard on local dev setup is not a problem. The header
should not be set in "production" to ensure only local same-host
queries get through.

Now that we combined servers this is unnecessary and extra headers
have been removed.

** NOTSURE Parse images on import for width/height?
CLOSED: [2020-03-01 Sun 19:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-03-01 Sun 19:54]
:END:

Pure exiftool output isn't enough. Raw files have funky resolutions
sometimes and do we dare to f.ex round up Leica M's 23.85 megapixels
up to 24?

Probably yes, but also no.

On JPEG files exif tags "ImageWidth" and "ImageHeight" seem to be
correct. Since we don't want to concern us with raw files (and the
whole resolution concept is not super clear) let's trust Phil on this
analysis.

** On accuracy of measurements ISO/Aperture/SS/EC

I would say that if we handle 1/3-stops and 1/2-stops decently from
floating point numbers it's accurate enough to be also statistically
useful.

After all, the DOF differences between f/2.76 and f/2.8 aren't going
to be visible. And movement at 1/28 seconds and 1/30 seconds is
equally blurry.

Light value is probably something we can just show with rounded to two
decimal places.

** DONE After import, clean empty and "empty" directories from inbox :inbox:backend:
CLOSED: [2020-05-17 Sun 16:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-17 Sun 16:41]
:END:
** DONE =photo.is_raw= should be a boolean 1/0, not a string :inbox:backend:
CLOSED: [2020-05-13 Wed 18:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-05-13 Wed 18:57]
:END:

Currently it is a string against the schema and we check its
booleanness by checking with =nil?=.

But it should be 0/1 in the first place.

Quick fix in sql

#+BEGIN_EXAMPLE
  update photo
  set is_raw = case when is_raw is null then 0 else 1 end;
#+END_EXAMPLE

Yep, currently the whole filter is broken.

SQLite constraint check would be cool here.

* Setting up the dev environment                                :emacs:cider:

System:

- Leiningen
- emacs + cider

Set up the deps and libraries:

: lein deps

Connect both at once as the good RMS intended.

: M-x cider-jack-in-clj&cljs

Figwheel-main starts our backend and serves frontend things, and is
running in port 9500 so head to http://localhost:9500 and see the
magic.

** DONE Combining servers
[2020-04-26 Sun]

We've hit several times to the issues that come from running a
figwheel server at port 9500 and then the rest of our clojure code at
port 8088.

Luckily this issue is well known by others too, so there's some help
available.

https://figwheel.org/docs/your_own_server.html

It is unclear whether the trick will exactly allow simultaneous
development of CLJ and CLJS.

Can we route (proxy) requests via figwheel's own server to port 8088?
Now browser ever only interacts with localhost:9500.

What we can do easily is supply the ring-handler so that running
figwheel-main connects to our clurator. Stuff this in for example
=dev.cljs.edn=.

#+BEGIN_EXAMPLE
  :ring-handler clurator.core/app
#+END_EXAMPLE

All good... Just remember to wipe out =server-uri= in core.cljs, so
that we connect to same-domain. The same will go for CSS references
and so on.

But now, what of modifying clurator code?!

Let's jack into the code, not sure what that did actually. Started a
new JVM, hopefully not?

Hmm, seems to work out of the box. Marvelous, so marvelous.

I believe the original =cider-jack-in-clj&cljs= will still do. Let's
try that out.
